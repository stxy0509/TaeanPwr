{
	"auto_complete":
	{
		"selected_items":
		[
			[
				"s",
				"s_stage"
			],
			[
				"t",
				"temp"
			],
			[
				"p",
				"parsed_block"
			],
			[
				"lat",
				"lat_mf"
			],
			[
				"lon",
				"lon_mf"
			],
			[
				"ret",
				"return"
			],
			[
				"T",
				"TM_20SEC"
			],
			[
				"uart",
				"uart_putch"
			],
			[
				"sta",
				"s_stage"
			],
			[
				"ms",
				"m_stage"
			],
			[
				"s_",
				"s_stage"
			],
			[
				"uar",
				"uart_putch"
			],
			[
				"wm",
				"wm_rcv_q_init"
			],
			[
				"mod",
				"MODEM"
			],
			[
				"dep",
				"depth_valid"
			],
			[
				"ec",
				"echoData"
			],
			[
				"la",
				"lat_md"
			],
			[
				"gp",
				"gps_valid"
			],
			[
				"l",
				"lon_mf"
			],
			[
				"debug",
				"debugprintf"
			],
			[
				"se",
				"sec"
			],
			[
				"PRI",
				"PRINT_TIME"
			],
			[
				"cat",
				"cat_fid"
			],
			[
				"def",
				"default"
			],
			[
				"SI",
				"SITE_TY_B101"
			],
			[
				"B",
				"BUOY_ID"
			],
			[
				"comb",
				"compass_heading_before"
			],
			[
				"com",
				"compass_heading"
			],
			[
				"qu",
				"queryReq_M0"
			],
			[
				"de",
				"debugprintf"
			],
			[
				"_",
				"_28673_M_00100_34785"
			],
			[
				"in",
				"init_flag"
			],
			[
				"re",
				"req_init"
			],
			[
				"val",
				"val_SR10"
			],
			[
				"i",
				"idx_Clk"
			],
			[
				"tick_1",
				"tick_1ms"
			],
			[
				"USE",
				"USE_MOSE"
			],
			[
				"tic",
				"tick_start"
			],
			[
				"ti",
				"tick_s2"
			],
			[
				"BA",
				"BAT_20"
			],
			[
				"deb",
				"debugprintf"
			],
			[
				"PR",
				"PRINTLINE"
			],
			[
				"sh",
				"shock_line"
			],
			[
				"m",
				"mbuf_L"
			],
			[
				"e",
				"e30_idx"
			],
			[
				"y",
				"year-2000"
			],
			[
				"rtc",
				"rtc_time"
			],
			[
				"ca",
				"calculated_humidity_true"
			],
			[
				"wif",
				"wifiprintf"
			],
			[
				"rcv",
				"rcv_cnt"
			],
			[
				"wi",
				"wifi_cmd"
			],
			[
				"cmd_st",
				"cmd_str4"
			],
			[
				"pr",
				"pressure"
			],
			[
				"init",
				"init_dpData"
			],
			[
				"dp",
				"dp_stk"
			],
			[
				"at",
				"atm1_data"
			],
			[
				"BU",
				"BUOY_SPEC"
			],
			[
				"f",
				"f_lat"
			],
			[
				"a_",
				"a_result"
			],
			[
				"c_",
				"c_code"
			],
			[
				"file",
				"fileSize"
			],
			[
				"fi",
				"fileSize"
			],
			[
				"PRINT",
				"PRINTLINE"
			],
			[
				"SH_PIN_DATA_",
				"SH_PIN_DATA_INPUT"
			],
			[
				"en",
				"enableHeartbeat"
			],
			[
				"deg",
				"debugprintf"
			],
			[
				"po",
				"pos_cnt"
			],
			[
				"do",
				"double"
			],
			[
				"pos",
				"pos_valid"
			],
			[
				"d",
				"double"
			],
			[
				"ref",
				"ref_lon"
			],
			[
				"set",
				"set_mt_status"
			],
			[
				"iri_",
				"iri_port"
			],
			[
				"f_",
				"f_lon"
			],
			[
				"get_sb",
				"get_sbdring2"
			],
			[
				"tm",
				"tm_chk_sbdreg"
			],
			[
				"ri",
				"ring1"
			],
			[
				"get",
				"get_mt_status"
			],
			[
				"C",
				"C_IRIDIUM_1"
			],
			[
				"mo",
				"mo_status"
			],
			[
				"ini",
				"init_flag"
			],
			[
				"temp",
				"temp_t"
			],
			[
				"mose",
				"mose_lat"
			],
			[
				"t_",
				"t_lon"
			],
			[
				"ch",
				"ch4_switch"
			],
			[
				"SDC",
				"SDC_TIME_TAG"
			],
			[
				"debu",
				"debugprintf"
			],
			[
				"sb2_",
				"sb2_ok_cnt"
			],
			[
				"sb",
				"sb1_ok_cnt"
			],
			[
				"sb2",
				"sb2_ok_cnt"
			],
			[
				"pre",
				"pressure_a"
			],
			[
				"ws",
				"ws_a"
			],
			[
				"m_",
				"m_system_robust_proc"
			],
			[
				"main_",
				"main_step_000"
			],
			[
				"mai",
				"main_step_001"
			],
			[
				"BAT",
				"BAT_STEP"
			],
			[
				"v",
				"valid"
			],
			[
				"b",
				"buoyNo"
			],
			[
				"TM_watchMO",
				"TM_watchMOSE1"
			],
			[
				"WT_M",
				"WT_MOSE1"
			],
			[
				"is",
				"is_special_ch_aio"
			],
			[
				"P",
				"PRINTVAR"
			],
			[
				"PRIN",
				"PRINTLINE"
			],
			[
				"GP",
				"GPS_LINE_MAX"
			],
			[
				"ne",
				"newMsg"
			],
			[
				"iri",
				"iri_port"
			],
			[
				"rt",
				"rt_now"
			],
			[
				"IM_",
				"IM_RCV"
			],
			[
				"IM",
				"IM_SEND"
			],
			[
				"st",
				"stMFP"
			],
			[
				"tim",
				"time_var"
			],
			[
				"SB",
				"SB_UART_MCR"
			],
			[
				"sb_get",
				"sb_get_register"
			],
			[
				"SB_UART_G",
				"SB_UART_GISR"
			],
			[
				"reg",
				"reg"
			],
			[
				"SB_UART_",
				"SB_UART_IER"
			],
			[
				"a",
				"a_baud"
			],
			[
				"debugp",
				"debugprintf"
			],
			[
				"te",
				"testbuf1"
			],
			[
				"at24",
				"at24cxx_eeprom_read"
			],
			[
				"str",
				"strlen"
			],
			[
				"AT",
				"at24cxx_eeprom_write"
			],
			[
				"cl",
				"clearHeartbeatEvent"
			],
			[
				"fl",
				"flagHeartbeatOn"
			],
			[
				"cmd_c",
				"cmd_cc"
			],
			[
				"SB_se",
				"SB_setSPR"
			],
			[
				"SB_g",
				"SB_getREG"
			],
			[
				"SB_s",
				"SB_setPortMode_DataOutput"
			]
		]
	},
	"buffers":
	[
		{
			"file": "source/k_main.c",
			"settings":
			{
				"buffer_size": 31568,
				"line_ending": "Windows"
			}
		},
		{
			"file": "source/k_config.h",
			"settings":
			{
				"buffer_size": 1984,
				"line_ending": "Windows"
			}
		},
		{
			"file": "source/k_rtc.c",
			"settings":
			{
				"buffer_size": 3956,
				"line_ending": "Windows"
			}
		},
		{
			"contents": "/*============================================\n	Simple Command Line Test Shell\n\n	08/27/04	mdj, created\n============================================*/\n#define __K_CLI_C__\n\n#define APP_DBG_PREFIX		\"\"\n\n#include \"k_includes.h\"\n\n\n\n#define MAX_LEN_CMD_STR		100      //100\n#define MAX_NO_ARGV			10       //10\n#define MAX_NO_CMD_REG		50      //20\n\n\nstatic int cli_start = 1;       //1: start , 0: stop\nstatic int cli_use_pt100 = 1;\nstatic int cli_use_bmp850 = 0;\n\nstatic float t_offset = 0;\nstatic float p_offset = 0;\nstatic s32 t_coef_00 = 1058;\nstatic s32 t_coef_40 = 2865;\n\nchar fwbuf[1024*512];\n\nvoid measure_BAT_leval(void);\nvoid set_ch4_switch(int a_onoff);\n\n\nint roundToInt(float x) {\n  if (x >= 0) return (int) (x + 0.5);\n  return (int) (x - 0.5);\n}\n\nfloat get_t_offset(void)\n{\n    return t_offset;\n}\nint get_p_offset(void)\n{\n    int tmp;\n    tmp = roundToInt(p_offset*100.0);\n    return tmp;\n}\n\ns32 get_t_coef_00(void)\n{\n    return t_coef_00;\n}\ns32 get_t_coef_40(void)\n{\n    return t_coef_40;\n}\n\n\nvoid set_t_offset(float a_off)\n{\n    t_offset = a_off;\n}\nvoid set_p_offset(float a_off)\n{\n    p_offset = a_off;\n}\nvoid set_t_coef_00(int a_off)\n{\n    t_coef_00 = a_off;\n}\nvoid set_t_coef_40(int a_off)\n{\n    t_coef_40 = a_off;\n}\n\nextern u32 d1_bat_level;\nvoid cmd_chkBat(void)\n{\n    //checkBattery();\n    //debugprintf(\"\\r\\n bat( %d )\\r\\n\",d1_bat_level);\n    debugprintf(\"\\r\\n bat\\r\\n\");\n}\n\n\n\n\nint cli_is_start(void)\n{\n    return cli_start;\n}\n\nint cli_is_use_pt100(void)\n{\n    return cli_use_pt100;\n}\n\nint cli_is_use_bmp850(void)\n{\n    return cli_use_bmp850;\n}\n\n\nstatic inline void SKIP_ONE_WORD(char **str)\n{\n	while (**str != ' ' && **str != 0)	 (*str)++;\n	while (**str == ' ' && **str != 0)	 (*str)++;\n}\n\ntypedef struct\n{\n	char *cmd;						// short command string\n	void (*fn)(int argc, char *args);		// function pointer to call to process command\n	char *help_str;					// help string to be printed by \"help\" command\n}\ncmd_registry_t;\n\n//static tTaskID thTestSh;\n\nstatic int cmd_cnt=0;\nstatic cmd_registry_t cmd_registry[MAX_NO_CMD_REG];\n\nstatic char cmd_str[MAX_LEN_CMD_STR];\n// static char cmd_str[MAX_LEN_CMD_STR];\nstatic int argc;\n//static int argv[MAX_NO_ARGV];\nstatic char args[MAX_NO_ARGV][20];\n\n//static char *format_str[] = {\"%x\", \"%d\"};\n//static int format_str_index = 0;\n\n\n/*\nstatic char *get_argv(char *cmd_str)\n{\n	int i;\n	char *pstr;\n\n	pstr = cmd_str;\n\n	SKIP_ONE_WORD(&pstr);\n\n	for (i=0; i<MAX_NO_ARGV; i++)\n	{\n		if (*pstr == 0)	return 0;\n\n		//sscanf(pstr, format_str[format_str_index], &argv[i]);\n		argv[i] = (int)strtol (pstr, (char **)NULL, format_str_index==0 ? 16 : 10);\n\n		argc++;\n		SKIP_ONE_WORD(&pstr);\n	}\n\n	return pstr;\n}\n*/\n\n\nstatic char *get_args(char *cmd_str)\n{\n	char *pstr;\n\n    //char p_data[10][10];\n    int i = 0;\n    int j = 0;\n    //int k = 0;\n    int spliter = 0;\n    char ch;\n    argc = 0;\n\n	pstr = cmd_str;\n\n    while (1)\n    {\n           ch = *pstr;  // a_str[k++];\n\n           if ((ch== 0x0D) || (ch== 0x0A) || ch=='\\0')\n           {\n               args[i][j] = '\\0';\n               //debugprintf(\"%s\\r\\n\", args[i]);\n               argc = (i+1);\n               //PRINTVAR(argc);\n               break;\n           }\n           else if (ch==' ')    // space\n           {\n               if (spliter == 0)\n               {\n                   spliter = 1;\n                   args[i][j] = '\\0';\n                   //debugprintf(\"%s\\r\\n\", args[i]);\n                   i++;\n                   j=0;\n               }\n           }\n           else\n           {\n               spliter = 0;\n               args[i][j++] = ch;\n           }\n           pstr++;\n    }\n	return pstr;\n}\n\n\n\n\n#if 0\nstatic int get_cmd_org()\n{\n	int i;\n\n	while (1)\n	{\n		debugstring (\"CMD> \");\n		fgets (cmd_str, MAX_LEN_CMD_STR, stdin);\n\n		//if(cmd_str[0] == 0) continue;\n		if (cmd_str[0]==0xa && cmd_str[1]==0) continue;\n\n		for (i=0; i<cmd_cnt; i++)\n		{\n			if (strncmp(cmd_str, cmd_registry[i].cmd, strlen(cmd_registry[i].cmd)) == 0)\n			{\n				get_argv(cmd_str);\n				return i;\n			}\n		}\n	}\n}\n#endif\n\nvoid wifistring ( const char *str )\n{\n    while ( *str )\n    {\n        // uart_putch ( 4, *str );\n        uart_putch ( 0, *str );\n        str++;\n    }\n}\n\nvoid wifiprintf ( const char *rsp, ... )\n{\n    short   int len = 0;\n    char print_buf[512];\n    va_list args;\n\n    if  ( rsp )\n    {\n        va_start ( args, rsp );\n        len = vsnprintf ( print_buf, sizeof ( print_buf ), rsp, args );\n        va_end ( args );\n    }\n\n    wifistring ( print_buf );\n}\n\n\n\n\nstatic int fgFW_updating = 0;\nint get_fgFW_updating(void) {   return (fgFW_updating); }\n\nstatic int fwUpadateWaitTime;\nvoid setFwUpadateWaitTime(void)\n{\n// PRINTLINE;\n// debugprintf(\"%s , %d \\r\\n\",__FILE__,__LINE__);\n    fwUpadateWaitTime = 10;\n}\nint getFwUpadateWaitTime(void)\n{\n    return(fwUpadateWaitTime);\n}\nvoid decFwUpadateWaitTime(void)\n{\n    if (fwUpadateWaitTime>0)\n    {\n// debugprintf(\"%s , %d \\r\\n\",__FILE__,__LINE__);\n// PRINTLINE;\n        fwUpadateWaitTime--;\n    }\n}\n\nstatic int fileSeletionID = 0;\nstatic int fileTransfer = 0;\nstatic int transFsize = 0;\nstatic int transFidx = 0;\nstatic int transTmpCnt = 0;\n\n#ifdef FLAG_FOR_DEBUGGING\nstatic int tst_index = 0;\n#endif\n\n//-----------------------------------------------------------\nstatic int wifi_reset_tm = WIFI_ON_TM;\nvoid revive_wifi(void)\n{\n    wifi_reset_tm = WIFI_ON_TM;\n}\nint dec_wifi_reset_tm(void)\n{\n    if (wifi_reset_tm > 0)\n    {\n        wifi_reset_tm--;\n    }\n    return wifi_reset_tm;\n}\n//-----------------------------------------------------------\n\n\n\n\n\nstatic void get_cmd()\n{\n\n    static char fwbuf[1024*512];\n    static int idx_getCmd = 0;\n    static int idx_cmdStr = 0;\n    static int fgFW_updateMode = 0;\n    int i;\n    char ch;\n\n    static u32 rcv_cnt = 0;\n    static u32 rcv_cnt1 = 0;\n\n\n	// static int idx_getCmd = 0;\n	// static int idx_cmdStr = 0;\n	// int i;\n	// char ch;\n\n	switch (idx_getCmd)\n	{\n		case 0x00:\n			//debugstring (\"CMD>\");\n			idx_cmdStr = 0;\n			idx_getCmd = 0x10;\n			break;\n\n		case 0x10:\n			//get 1byte until meet 0x0D...\n			if (uart_getch(0,&ch)) //receive\n			{\n                //uart_putch(0,ch);\n                //sb_uart_putch ( SB_S_ATM2, ch );\n\n				if (idx_cmdStr < MAX_LEN_CMD_STR-3)\n				{\n					if (ch==0x0D)\n					{\n						cmd_str[idx_cmdStr++] = 0x0D;\n						cmd_str[idx_cmdStr++] = 0x0A;\n						cmd_str[idx_cmdStr++] = 0;\n\n						if (cmd_str[1]==0xa && cmd_str[2]==0)\n						{\n							idx_getCmd = 0x99;\n						}\n                        else\n						{\n\n                            //PRINTLINE;\n							idx_getCmd = 0x20;\n							//debugstring(cmd_str);\n						}\n					}\n                    else if ( (ch== '#') )\n                    {\n                        int wifi_cmd = 0;\n                        int i=0;\n                        cmd_str[idx_cmdStr++] = '\\0';\n\n                        wifi_cmd= atoi(&cmd_str[0]);\n                        debugprintf(\"command(%s): %d\\r\\n\", cmd_str, wifi_cmd);\n                        wifiprintf(\"command(%s): %d\\r\\n\", cmd_str, wifi_cmd);\n\n\n                        idx_getCmd = 0x99;\n\n                        if ( (wifi_cmd>=6000) && (wifi_cmd<=6255) )\n                        {\n                            i = wifi_cmd;\n                            wifi_cmd = 6000;\n                        }\n\n                        switch(wifi_cmd)\n                        {\n                            // LOG ON\n                            case 5000:\n                                break;\n                            // LOG OFF\n                            case 5001:\n                                break;\n                            // 전송주기\n                            case 5501:  env_set_interval(10);   break;\n                            case 5502:  env_set_interval(20);   break;\n                            case 5503:  env_set_interval(30);   break;\n                            case 5504:  env_set_interval(60);   break;\n                            case 5505:  env_set_interval(120);  break;\n                            // 기준위치 해제\n                            case 5551:\n                                env.ref_flag = 0;\n                                env_save();\n                                // debugstring(\"env.ref_flag is cleared.\\r\\n\");\n                                wifistring(\"env.ref_flag is cleared.\\r\\n\");\n                                break;\n                            // TRBM RESET\n                            case 5800:\n                                break;\n                            // TRBM Tync\n                            case 5802:\n                                {\n                                    char tmp_buf[25];\n\n                                    wifistring(\"TRBM timesync with RTC\\r\\n\");\n                                    // sprintf(tmp_buf,\"%%+T1%02d%02d%02d%02d%02d%02d\\r\",rtc_time.year%100,rtc_time.mon,rtc_time.day,rtc_time.hour,rtc_time.min,rtc_time.sec);\n                                    // sb_printstring(SB_S_ATM1, tmp_buf);\n                                    // sb_printstring(SB_S_ATM2, tmp_buf);\n                                    // sb_uart_putch(SB_S_ATM2, 0x13);\n                                    // sb_uart_putch(SB_S_ATM2, 0x10);\n                                    wifistring(tmp_buf);\n                                }\n                                break;\n                            // 충격량 설정\n                            case 6000:\n                                env_set_shock(i-6000);\n                                wifiprintf(\"env.shock(%d) is set.\\r\\n\", i-6000);\n                                break;\n\n                            // 시스템 리셋\n                            case 8001:\n                                // debugstring(\"system reset.\\r\\n\");\n                                // wifistring(\"system reset.\\r\\n\");\n                                // delayms(100);\n                                // cmdSensorControl('8', '0');\n                                break;\n\n                            // data retrieve\n                            case 3001:  fileTransfer = 1;\n                            case 2001:\n                                fileSeletionID = 1;\n                                idx_getCmd = 0x50;\n                                break;\n                            case 3002:  fileTransfer = 1;\n                            case 2002:\n                                fileSeletionID = 2;\n                                idx_getCmd = 0x50;\n                                break;\n                            case 3003:  fileTransfer = 1;\n                            case 2003:\n                                fileSeletionID = 3;\n                                idx_getCmd = 0x50;\n                                break;\n                            case 3004:  fileTransfer = 1;\n                            case 2004:\n                                fileSeletionID = 4;\n                                idx_getCmd = 0x50;\n                                break;\n                            case 3005:  fileTransfer = 1;\n                            case 2005:\n                                fileSeletionID = 5;\n                                idx_getCmd = 0x50;\n                                break;\n                            case 3006:  fileTransfer = 1;\n                            case 2006:\n                                fileSeletionID = 6;\n                                idx_getCmd = 0x50;\n                                break;\n                            case 3007:  fileTransfer = 1;\n                            case 2007:\n                                fileSeletionID = 7;\n                                idx_getCmd = 0x50;\n                                break;\n                            case 3008:  fileTransfer = 1;\n                            case 2008:\n                                fileSeletionID = 8;\n                                idx_getCmd = 0x50;\n                                break;\n                            case 3009:  fileTransfer = 1;\n                            case 2009:\n                                fileSeletionID = 9;\n                                idx_getCmd = 0x50;\n                                break;\n                            case 3010:  fileTransfer = 1;\n                            case 2010:\n                                fileSeletionID = 10;\n                                idx_getCmd = 0x50;\n                                break;\n                            case 3011:  fileTransfer = 1;\n                            case 2011:\n                                fileSeletionID = 11;\n                                idx_getCmd = 0x50;\n                                break;\n                            // case 2012:\n                            //     fileSeletionID = 12;\n                            //     idx_getCmd = 0x50;\n                            //     break;\n\n                            // FW update\n                            case 9999:\n                                wifistring(\"FW update mode...\\r\\n\");\n                                // deugstring(\"FW update mode...\\r\\n\");\n                                fgFW_updateMode = 1;\n\n                                // set_debug_channel(0);\n\n                                idx_getCmd = 0x40;\n                                break;\n\n\n\n\n\n                        }\n                        // idx_getCmd = 0x99;\n\n                    }\n\n                    else if (ch==0x0A)\n					{\n                    }\n                    else if (ch==0x08)    //BS\n                    {\n                        //if (idx_cmdStr>0)\n                        //{\n                        //    idx_cmdStr--;\n                        //}\n					}\n                    else\n					{\n						cmd_str[idx_cmdStr++] = ch;\n					}\n				} else\n				{\n					idx_getCmd = 0x99;\n					debugstring(\"input string is over MAX_LEN_CMD_STR.\\r\\n\");\n					debugstring(\"the string is discarded.\\r\\n\");\n				}\n			}\n			break;\n\n		case 0x20:\n			for (i=0; i<cmd_cnt; i++)\n			{\n                //PRINTVAR(i);\n\n				if (strncmp(cmd_str, cmd_registry[i].cmd, strlen(cmd_registry[i].cmd)) == 0)\n				{\n					//get_argv(cmd_str);\n                    //PRINTLINE;\n					get_args(cmd_str);\n\n					//cmd_registry[i].fn(argc, argv);\n					cmd_registry[i].fn(argc, args);\n                    argc = 0;\n                    {\n                        int j;\n                        for (j=0; j<MAX_NO_ARGV; j++)\n                        {\n                            //argv[i] = 0;\n                            args[j][0] = '0';\n                        }\n                    }\n\n				}\n			}\n			idx_getCmd = 0x99;\n			break;\n\n\n        case 0x40:\n            // FW update mode...\n// debugprintf(\"%s , %d \\r\\n\",__FILE__,__LINE__);\n            fgFW_updating = 1;\n\n            setFwUpadateWaitTime();\n            idx_getCmd = 0x42;\n            break;\n        case 0x42:\n            fgFW_updating = 1;\n\n            // FW update mode...\n            if (getFwUpadateWaitTime()==0)\n            {\n// debugprintf(\"%s , %d \\r\\n\",__FILE__,__LINE__);\n                wifistring(\"\\r\\nexit FW update mode...\\r\\n\");\n                idx_getCmd = 0x99;\n            }\n            else\n            {\n                if (uart_getch(0,&ch)) //receive\n                {\n                    wifi_reset_tm = WIFI_ON_TM;\n\n                    if (ch=='#')\n                    {\n                        // wifistring(\"'0xC0' received (START SIGNAL)...\\r\\n\");\n                        rcv_cnt = 0;\n                        rcv_cnt1 = 0;\n\n                        idx_getCmd = 0x44;\n\n                        // enable_interrupt(INTNUM_EIRQ0, FALSE);\n                        // enable_interrupt(INTNUM_EIRQ1, FALSE);\n\n                        setFwUpadateWaitTime();\n                        debugprintf(\"\\r\\nstart\\r\\n00000: \");\n                        wifiprintf(\"\\r\\nstart\\r\\n00000: \");\n\n\n                    }\n                }\n            }\n            break;\n        case 0x44:\n            fgFW_updating = 1;\n\n            if (getFwUpadateWaitTime()==0)\n            {\n// PRINTLINE;\n                for (i=0;i<1024;i++)\n                {\n                    if (uart_getch(0,&ch)) //receive\n                    {\n                        wifi_reset_tm = WIFI_ON_TM;\n                    }\n                    else\n                        {   break;  }\n                }\n\n                wifistring(\"\\r\\nexit FW update mode...\\r\\n\");\n\n                debugprintf(\"rcv_cnt= %d (273*1024)\\r\\n\", rcv_cnt);  // 279552\n                // debugprintf(\"rcv_cnt= %d (358400)\\r\\n\", rcv_cnt);\n                // wifiprintf(\"rcv_cnt= %d (358400)\\r\\n\", rcv_cnt);\n\n\n\n                // if (rcv_cnt == 358400)\n                if (rcv_cnt == 273*1024)\n                {\n                    //extern const unsigned int bootloader_trip_elf_bin_len;\n                    int i;\n                    int fileSize_bak = 273*1024;\n                    // int sectors = bootloader_trip_elf_bin_len/flash_get_sectorsize();\n                    int sectors = fileSize_bak/flash_get_sectorsize();\n                    // if(bootloader_trip_elf_bin_len % flash_get_sectorsize())\n                    if(fileSize_bak % flash_get_sectorsize())\n                        sectors++;\n                    // wifistring(\"erase application sectors...\\r\\n\");\n                    debugstring(\"erase application sectors...\\r\\n\");\n                    for(i=20;i<(sectors+20);i++)\n                    {\n                        // debugprintf(\"%d sector\\r\\n\",i);\n                        // wifistring(\".\");\n                        debugstring(\".\");\n\n                        flash_erase_sector(i,1);\n                    }\n                    // wifistring(\"\\r\\nupdate....\");\n                    debugstring(\"update....\\r\\n\");\n                    // flash_write(0,(BYTE*)bootloader_trip_elf_bin,bootloader_trip_elf_bin_len);\n                    flash_write(0x14000,(BYTE*)fwbuf,fileSize_bak);\n                    // wifistring(\"completed\\r\\n\");\n                    debugstring(\"completed\\r\\n\");\n                }\n                else\n                {\n                    // wifistring(\"FW update canceled...\\r\\n\");\n                    debugstring(\"FW update canceled...\\r\\n\");\n\n                }\n\n\n                // enable_interrupt(INTNUM_EIRQ0, TRUE);   // 131008\n                // enable_interrupt(INTNUM_EIRQ1, TRUE);\n\n                idx_getCmd = 0x99;\n            }\n            else\n            {\n                int  i;\n                // for (i=0;i<512;i++)\n                for (i=0;i<4000;i++)\n                {\n                    if (uart_getch(0,&ch)) //receive\n                    {\n                        wifi_reset_tm = WIFI_ON_TM;\n\n                        // if (ch==0xC0)\n                        // {\n                        //     wifiprintf(\"%04X ( %d ) \", rcv_cnt,rcv_cnt);\n                        //     wifistring(\"'0xC0' received (END SIGNAL)...\\r\\n\");\n                        //     idx_getCmd = 0x99;\n                        // }\n                        // else\n                        {\n                            // debugprintf(\"%02X \", (u8)ch);\n                            // wifiprintf(\"%02X \", (u8)ch);\n                            //debugstring(\".\");\n                            //wifistring(\".\");\n                            fwbuf[rcv_cnt++] = ch;\n                            if (++rcv_cnt1 > 15)\n                            {\n                                rcv_cnt1 = 0;\n                                // debugprintf(\"\\r\\n%05X: \",rcv_cnt);\n                                // wifiprintf(\"\\r\\n%05X: \",rcv_cnt);\n                                // debugstring(\".\");\n                                wifiprintf(\"\\r\\n%05X\",rcv_cnt);\n                            }\n                            //rcv_cnt++;\n\n                            // if (rcv_cnt >(512*1024))\n                            //     idx_getCmd = 0x46;\n\n                        }\n                        setFwUpadateWaitTime();\n                    }\n                    else\n                    {\n                        break;\n                    }\n                }\n            }\n            break;\n\n        case 0x46:\n            debugstring(\"verify start\\r\\n\");\n            idx_getCmd = 0x99;\n            break;\n\n        case 0x50:\n            if (fileTransfer==1)\n            {\n                // 파일전송모드로...\n                transTmpCnt = 0;\n                transFsize = 0;\n                transFidx = 0;\n                idx_getCmd = 0x60;\n\n#ifdef FLAG_FOR_DEBUGGING\n                tst_index = 0;\n#endif\n                break;\n            }\n\n            {\n                FRESULT  res;\n                FIL fp;\n\n                char t_item[100];\n                char buf[1460*3];\n                int len;\n                char *c;\n\n                int fileSize;\n                int nRead;\n                //int i;\n                int position = 0;\n                //int tmp_idx = 0;\n\n                c = &buf[0];\n\n                switch(fileSeletionID)\n                {\n\n                    case 1: strcpy(t_item,\"1:ai.dat\");  break;\n                    case 2: strcpy(t_item,\"1:ct.dat\");  break;\n                    case 3: strcpy(t_item,\"1:zp.dat\");  break;\n                    case 4: strcpy(t_item,\"1:t1.dat\");  break;\n                    case 5: strcpy(t_item,\"1:t2.dat\");  break;\n                    case 6: strcpy(t_item,\"1:hm.dat\");  break;\n                    case 7: strcpy(t_item,\"1:pt.dat\");  break;\n                    case 8: strcpy(t_item,\"1:sh.dat\");  break;\n                    case 9: strcpy(t_item,\"1:gp.dat\");  break;\n                    case 10: strcpy(t_item,\"1:mo.dat\");  break;\n                    case 11: strcpy(t_item,\"1:se.dat\");  break;\n                }\n\n                debugprintf(\"t_item(%s)\\r\\n\",t_item);\n\n                res = f_open(&fp,t_item, FA_READ|FA_OPEN_EXISTING);   //delayms(5);\n                if (res != FR_OK)\n                {\n                    debugprintf(\"faild f_open(%s) : res : %d\\r\\n\",t_item, res);\n                    idx_getCmd = 0x99;\n                    break;\n                }\n\n                fileSize = f_size(&fp);\n                debugprintf(\"fileSize( %d )\\r\\n\", fileSize);\n\n\n                if (fileSize >(1460*2-1))\n                {\n// PRINTLINE;\n                    len = (1460*2)-1;\n                    position = fileSize - (1460*2-1);\n                }\n                else\n                {\n// PRINTLINE;\n                    len = fileSize;\n                    position = 0;\n                }\n\n// PRINTLINE;\n                f_lseek(&fp, position);   //delayms(5);\n\n// PRINTLINE;\n                f_read(&fp,c,len,&nRead);\n                f_close(&fp);\n\n                buf[len]='\\0';\n\n// PRINTLINE;\n                debugprintf(\"len( %d ), nRead( %d )\\r\\n\", len, nRead);\n                // debugstring(buf);\n                wifistring(buf);\n// PRINTLINE;\n\n            }\n            idx_getCmd = 0x99;\n            break;\n\n        case 0x60:\n            {\n                //static int tmp_cnt = 0;\n\n                FRESULT  res;\n                FIL fp;\n\n                char t_item[100];\n                char buf[1460*3];\n                int len;\n                char *c;\n\n                //int fileSize;\n                int nRead;\n                //int i;\n                int position = 0;\n                //int tmp_idx = 0;\n\n                c = &buf[0];\n\n                switch(fileSeletionID)\n                {\n\n                    case 1: strcpy(t_item,\"1:ai.dat\");  break;  // aio\n                    case 2: strcpy(t_item,\"1:ct.dat\");  break;  // aio\n                    case 3: strcpy(t_item,\"1:zp.dat\");  break;  // aio\n                    case 4: strcpy(t_item,\"1:t1.dat\");  break;  // aio\n                    case 5: strcpy(t_item,\"1:t2.dat\");  break;  // aio\n                    case 6: strcpy(t_item,\"1:hm.dat\");  break;  // aio\n                    case 7: strcpy(t_item,\"1:pt.dat\");  break;  // aio\n                    case 8: strcpy(t_item,\"1:sh.dat\");  break;  // aio\n                    case 9: strcpy(t_item,\"1:gp.dat\");  break;  // aio\n                    case 10: strcpy(t_item,\"1:mo.dat\");  break;  // aio\n                    case 11: strcpy(t_item,\"1:se.dat\");  break;  // aio\n                }\n\n                debugprintf(\"t_item(%s)\\r\\n\",t_item);\n\n                res = f_open(&fp,t_item, FA_READ|FA_OPEN_EXISTING);   //delayms(5);\n                if (res != FR_OK)\n                {\n                    debugprintf(\"faild f_open(%s) : res : %d\\r\\n\",t_item, res);\n                    fileTransfer = 0;\n                    transFsize = 0;\n                    transFidx = 0;\n                    idx_getCmd = 0x99;\n                    break;\n                }\n\n                //fileSize = f_size(&fp);\n                transFsize = f_size(&fp);\n                debugprintf(\"Trans fileSize( %d, %d)\\r\\n\", transFsize, transFidx);\n\n                if (transFidx >= transFsize)\n                {\n                    // 전송완료...\n                    fileTransfer = 0;\n                    transFsize = 0;\n                    transFidx = 0;\n\n                    idx_getCmd = 0x99;\n                    break;\n                }\n\n                // 전송한다...\n                position = transFidx;\n\n                if ((transFsize-transFidx) >(1460))\n                {\n// PRINTLINE;\n                    // len = (1460);\n                    len = (1460);\n                    transFidx += len;\n                }\n                else\n                {\n// PRINTLINE;\n                    len = transFsize-transFidx;\n\n                    fileTransfer = 0;\n                    transFsize = 0;\n                    transFidx = 0;\n                    idx_getCmd = 0x99;\n\n                }\n\n// PRINTLINE;\n                f_lseek(&fp, position);   //delayms(5);\n\n// PRINTLINE;\n                f_read(&fp,c,len,&nRead);\n                f_close(&fp);\n\n                buf[len]='\\0';\n\n// PRINTLINE;\n                debugprintf(\"len( %d ), nRead( %d )\\r\\n\", len, nRead);\n                // debugstring(buf);\n\n// #ifdef FLAG_FOR_DEBUGGING\n//                 sprintf(buf,\"%07d: 123456789abcdefghijklmnopqrstuvwxyz_123456789abcdefghijklmnopqrstuvwxyz\\r\\n\",tst_index++);\n// #endif\n                wifistring(buf);\n\n                if (fileTransfer>0)\n                {\n                    tick_fileTx=3;  //1s\n                    idx_getCmd = 0x61;\n                    break;\n\n\n\n\n                    if(++transTmpCnt >300)\n                    {\n                        transTmpCnt = 0;\n                    }\n                    else\n                    {\n                        switch(transTmpCnt)\n                        {\n                            case 25:\n                            case 75:\n                            case 125:\n                            case 175:\n                            case 225:\n                            case 275:\n                                tick_fileTx=100;  //1s\n                                break;\n                            case 50:\n                            case 100:\n                            case 150:\n                            case 200:\n                            case 250:\n                            case 300:\n                                tick_fileTx=300;  //1s\n                                break;\n                        }\n\n                    }\n                    idx_getCmd = 0x61;\n                }\n            }\n            //idx_getCmd = 0x99;\n            break;\n\n        case 0x61:\n            if (tick_fileTx==0)\n            // if (uart_getch(4,&ch)) //receive\n\n            {\n                idx_getCmd = 0x60;\n            }\n            break;\n\n\n		case 0x99:\n		default:\n			idx_getCmd = 0x00;\n			break;\n	}\n}\n\n\n\n\nint task_cmdshell()\n{\n    get_cmd();\n	// get_cmd4();\n	return 0;\n}\n\nvoid testSh_RegisterCmd (char *cmd, void (*fn)(int argc, int *argv), char *help_str)\n{\n	cmd_registry[cmd_cnt].cmd = (char *)malloc(strlen(cmd)+1);\n	strcpy(cmd_registry[cmd_cnt].cmd, cmd);\n\n	cmd_registry[cmd_cnt].fn = fn;\n\n	cmd_registry[cmd_cnt].help_str = (char *)malloc(strlen(help_str)+1);\n	strcpy(cmd_registry[cmd_cnt].help_str, help_str);\n\n	cmd_cnt++;\n}\n\n\n\n\nstatic void cmd_help()\n{\n	int i;\n\n	for (i=0; i<(cmd_cnt); i++)\n	{\n		debugstring (cmd_registry[i].help_str);\n	}\n}\n\n\nstatic void cmd_pos()\n{\n    // double p1x, p1y, p2x, p2y;\n    // double dist;\n\n    // if (argc<5)\n    // {\n    //     debugstring (\"  need <5 value>\\r\\n\");\n    //     return;\n    // }\n\n    // debugprintf(\"\\r\\np1x= %s, p1y= %s, p2x= %s, p2y= %s\", args[1], args[2], args[3], args[4]);\n    // p1x = atof(args[1]);\n    // p1y = atof(args[2]);\n    // p2x = atof(args[3]);\n    // p2y = atof(args[4]);\n    // debugprintf(\"\\r\\np1x= %f, p1y= %f, p2x= %f, p2y= %f\", p1x, p1y, p2x, p2y);\n\n    // dist = pos_distance(p1x, p1y, p2x, p2y);\n    // debugprintf(\"\\r\\ndist= %f\", dist);\n\n}\n\nvoid cmd_sbr(void)\n{}\n\nvoid cmd_sbw(void)\n{}\n\n\nstatic void cmd_at(void)\n{\n    // print_string (3, \"AT\\r\\n\");\n}\n\nstatic void cmd_mv(void)\n{\n    if (argc<2)\n    {\n        debugstring (\"  mv <mo zp ai all>\\r\\n\");\n        return;\n    }\n\n    if ( (!strncmp( args[1], \"mo\", 2)))\n    {\n        SensorBakSize.b.mose = 1;\n    }\n\n    if ( (!strncmp( args[1], \"zp\", 2)))\n    {\n        SensorBakSize.b.dcs = 1;\n    }\n    if ( (!strncmp( args[1], \"ai\", 2)))\n    {\n        SensorBakSize.b.aio = 1;\n    }\n    if ( (!strncmp( args[1], \"all\", 3)))\n    {\n        SensorBakSize.b.shock = 1;\n        SensorBakSize.b.send = 1;\n        SensorBakSize.b.atm1 = 1;\n        SensorBakSize.b.atm2 = 1;\n        SensorBakSize.b.history = 1;\n        SensorBakSize.b.ptb210 = 1;\n        SensorBakSize.b.dcs = 1;\n        SensorBakSize.b.ct3919 = 1;\n        SensorBakSize.b.hmp155 = 1;\n        SensorBakSize.b.gps = 1;\n        SensorBakSize.b.aio = 1;\n        SensorBakSize.b.mose = 1;\n    }\n    chk_file_size();\n}\n\n\nstatic void cmd_gg(void)\n{\n    // debugstring(\"hello wifi???\");\n}\n\n\nstatic void cmd_qq(void)\n{\n    // (*R_GPOLOW(5)  |= (1<<2) );\n    // delayms(10);\n    // (*R_GPOHIGH(5) |= (1<<2) );\n}\n\nstatic void cmd_ss(void)\n{\n}\n\nstatic void cmd_uu(void)\n{\n    // int a_chan = get_debug_channel();\n\n    // if (a_chan == 0)\n    // {\n    //     // set_debug_channel(4);\n    //     // wifistring(\"debug out: wifi\\r\\n\");\n    //     // debugstring(\"debug out: wifi\\r\\n\");\n    // }\n    // else\n    // {\n    //     // set_debug_channel(0);\n    //     // wifistring(\"debug out: serial\\r\\n\");\n    //     // debugstring(\"debug out: serial\\r\\n\");\n    // }\n}\n// static void cmd_msg(void)\n// {\n//     char buf[21];\n//     if (argc<2)\n//     {\n//         debugstring (\"  msg d10/d11\\r\\n\");\n//         return;\n//     }\n\n//     debugprintf(\"\\r\\nmsg : %s\", args[1]);\n\n//     if (strncmp( args[1], \"d10\", 3)==0)\n//     {\n//         make_msg_k1();\n//     }\n//     else if (strncmp( args[1], \"d1105\", 3)==0)\n//     {\n//         make_msg_press_5();\n//     }\n//     else if (strncmp( args[1], \"d1130\", 3)==0)\n//     {\n//         make_msg_press_30();\n//     }\n// }\nstatic void cmd_xx(void)\n{\n    // if (get_ch4_switch())\n    // {\n    //     debugstring(\"wifi debug message OFF\\r\\n\");\n    //     set_ch4_switch(0);\n    // }\n    // else\n    // {\n    //     debugstring(\"wifi debug message ON\\r\\n\");\n    //     set_ch4_switch(1);\n    // }\n\n}\nstatic void cmd_yy(void)\n{\n}\nstatic void cmd_zz(void)\n{\n}\n\n\nstatic void cmd_env(void)\n{\n    //char buf[21];\n    if (argc<2)\n    {\n        debugstring (\"  env <[init] [save] [read]>\\r\\n\");\n        return;\n    }\n\n    debugprintf(\"\\r\\nenv : %s\", args[1]);\n\n    if (strncmp( args[1], \"init\", 4)==0)\n    {\n        //init\n        env_init();\n    }\n    else if (strncmp( args[1], \"save\", 4)==0)\n    {\n        env_save();\n    }\n    else if (strncmp( args[1], \"read\", 4)==0)\n    {\n        env_read();\n    }\n    else if ( (!strncmp( args[1], \"print\", 4)) ||\n              (!strncmp( args[1], \"pr\", 2)) )\n    {\n        env_print();\n    }\n}\n\nstatic void cmd_ts(void)\n{\n    // //char buf[21];\n    // if (argc<2)\n    // {\n    //     debugstring (\"  ts <10,11(CR),12(CRLF),13(CRLF2)/20,21,22,23>\\r\\n\");\n    //     return;\n    // }\n\n    // debugprintf(\"\\r\\nts : %s\", args[1]);\n\n    // if (strncmp( args[1], \"10\", 2)==0)\n    // {\n    //     char tmp_buf[50];\n\n    //     sprintf(tmp_buf,\"\\r\\n%%+T1%02d%02d%02d%02d%02d%02d\",rtc_time.year%100,rtc_time.mon,rtc_time.day,rtc_time.hour,rtc_time.min,rtc_time.sec);\n    //     // sb_printstring(SB_S_ATM1, tmp_buf);\n    //     debugstring(tmp_buf);\n    // }\n    // else if (strncmp( args[1], \"11\", 2)==0)\n    // {\n    //     char tmp_buf[50];\n\n    //     sprintf(tmp_buf,\"\\r\\n%%+T1%02d%02d%02d%02d%02d%02d\\r\",rtc_time.year%100,rtc_time.mon,rtc_time.day,rtc_time.hour,rtc_time.min,rtc_time.sec);\n    //     // sb_printstring(SB_S_ATM1, tmp_buf);\n    //     debugstring(tmp_buf);\n    // }\n    // else if (strncmp( args[1], \"12\", 2)==0)\n    // {\n    //     char tmp_buf[50];\n\n    //     sprintf(tmp_buf,\"\\r\\n%%+T1%02d%02d%02d%02d%02d%02d\\r\\n\",rtc_time.year%100,rtc_time.mon,rtc_time.day,rtc_time.hour,rtc_time.min,rtc_time.sec);\n    //     // sb_printstring(SB_S_ATM1, tmp_buf);\n    //     debugstring(tmp_buf);\n    // }\n    // else if (strncmp( args[1], \"13\", 2)==0)\n    // {\n    //     char tmp_buf[50];\n\n    //     sprintf(tmp_buf,\"\\r\\n%%+T1%02d%02d%02d%02d%02d%02d\\r\\n\\r\\n\",rtc_time.year%100,rtc_time.mon,rtc_time.day,rtc_time.hour,rtc_time.min,rtc_time.sec);\n    //     // sb_printstring(SB_S_ATM1, tmp_buf);\n    //     debugstring(tmp_buf);\n    // }\n    // else if (strncmp( args[1], \"20\", 2)==0)\n    // {\n    //     char tmp_buf[50];\n\n    //     sprintf(tmp_buf,\"\\r\\n%%+T1%02d%02d%02d%02d%02d%02d\",rtc_time.year%100,rtc_time.mon,rtc_time.day,rtc_time.hour,rtc_time.min,rtc_time.sec);\n    //     sb_printstring(SB_S_ATM2, tmp_buf);\n    //     debugstring(tmp_buf);\n    // }\n    // else if (strncmp( args[1], \"21\", 2)==0)\n    // {\n    //     char tmp_buf[50];\n\n    //     sprintf(tmp_buf,\"\\r\\n%%+T1%02d%02d%02d%02d%02d%02d\\r\",rtc_time.year%100,rtc_time.mon,rtc_time.day,rtc_time.hour,rtc_time.min,rtc_time.sec);\n    //     sb_printstring(SB_S_ATM2, tmp_buf);\n    //     debugstring(tmp_buf);\n    // }\n    // else if (strncmp( args[1], \"22\", 2)==0)\n    // {\n    //     char tmp_buf[50];\n\n    //     sprintf(tmp_buf,\"\\r\\n%%+T1%02d%02d%02d%02d%02d%02d\\r\\n\",rtc_time.year%100,rtc_time.mon,rtc_time.day,rtc_time.hour,rtc_time.min,rtc_time.sec);\n    //     sb_printstring(SB_S_ATM2, tmp_buf);\n    //     debugstring(tmp_buf);\n    // }\n    // else if (strncmp( args[1], \"23\", 2)==0)\n    // {\n    //     char tmp_buf[50];\n\n    //     sprintf(tmp_buf,\"\\r\\n%%+T1%02d%02d%02d%02d%02d%02d\\r\\n\\r\\n\",rtc_time.year%100,rtc_time.mon,rtc_time.day,rtc_time.hour,rtc_time.min,rtc_time.sec);\n    //     sb_printstring(SB_S_ATM2, tmp_buf);\n    //     debugstring(tmp_buf);\n    // }\n    // else if (strncmp( args[1], \"24\", 2)==0)\n    // {\n    //     char tmp_buf[50];\n\n    //     sprintf(tmp_buf,\"\\r\");//,rtc_time.year%100,rtc_time.mon,rtc_time.day,rtc_time.hour,rtc_time.min,rtc_time.sec);\n    //     sb_printstring(SB_S_ATM2, tmp_buf);\n    //     debugstring(tmp_buf);\n    // }\n}\n\nvoid SHT7x_Transmission_Start();\nu32 SHT7x_Write(unsigned char a_data);   //read=1, write = 0\nint  SHT7x_ACK_Delay_Check();\nvoid SHT7x_Soft_Reset();\nvoid SHT7x_Connection_Reset_Sequence();\nunsigned char SHT7x_Read(int ack);\nvoid SHT7x_init();\n\n\n\nstatic void cmd_msg(void)\n{\n//     //char buf[21];\n//     if (argc<2)\n//     {\n//         debugstring (\"  msg <[init] [save] [read]>\\r\\n\");\n//         return;\n//     }\n\n//     debugprintf(\"\\r\\nmsg : %s\", args[1]);\n\n//     if (strncmp( args[1], \"k0\", 2)==0)\n//     {\n//         make_msg_kx('0');\n//     }\n//     else if (strncmp( args[1], \"k1\", 2)==0)\n//     {\n//         make_msg_k1();\n//     }\n//     else if (strncmp( args[1], \"kx\", 2)==0)\n//     {\n//         make_msg_kx('9');\n//     }\n//     else if (strncmp( args[1], \"ky\", 2)==0)\n//     {\n//         make_msg_ky('E',0);\n//     }\n//     else if (strncmp( args[1], \"d0\", 2)==0)\n//     {\n//         make_msg_kx('0');\n//     }\n//     else if (strncmp( args[1], \"d1\", 2)==0)\n//     {\n//         make_msg_k1();\n//     }\n// #if (BUOY_SPEC == 'D')\n\n//     else if (strncmp( args[1], \"d5\", 2)==0)\n//     {\n//         make_msg_press_5();\n//     }\n//     else if (strncmp( args[1], \"d30\", 2)==0)\n//     {\n//         make_msg_press_30();\n//     }\n// #endif\n}\n\n\n\nstatic void cmd_syscmd(void)\n{\n}\n\nstatic void cmd_set(void)\n{\n    //char buf[21];\n    if (argc<2)\n    {\n        debugstring (\"  set <arg...>\\r\\n\");\n        return;\n    }\n\n    //debugprintf(\"\\r\\nenv : %s\", args[1]);\n\n    if ( (!strncmp( args[1], \"heartbeat\", 9)) ||\n         (!strncmp( args[1], \"hb\", 2)) )\n    {\n        // enable,disable Heartbeat\n        if (argc<3)\n        {\n            debugstring (\"  ex) set heartbeat ['0'||'1']\\r\\n\");\n            return;\n        }\n        switch(args[2][0])\n        {\n            // case '0':   setEnableHeartbeat(0);  break;\n            // case '1':   setEnableHeartbeat(1);  break;\n        }\n    }\n    else if ( (!strncmp( args[1], \"env\", 3)))\n    {\n        if ( (!strncmp( args[2], \"interval\", 8)) ||\n             (!strncmp( args[2], \"int\", 3)) )\n        {\n            if (argc<4)\n            {\n                debugstring (\"  ex) set env interval(int) [10||20||30||60||120]\\r\\n\");\n                return;\n            }\n            {\n                int k = atoi(args[3]);\n                switch(k)\n                {\n                    case 5:\n                    case 10:\n                    case 20:\n                    case 30:\n                    case 60:\n                    case 120:\n                        env.interval = k;\n                        debugprintf(\"set : env.interval = %d\\r\\n\", k);\n                        break;\n                }\n            }\n        }\n        else if ( (!strncmp( args[2], \"mode\", 4)) ||\n             (!strncmp( args[2], \"md\", 2)) )\n        {\n            if (argc<4)\n            {\n                debugstring (\"  ex) set env mode(md) [0|1]\\r\\n\");\n                return;\n            }\n            {\n                int k = atoi(args[3]);\n                switch(k)\n                {\n                    case 0:\n                    case 1:\n                        env.mode = k;\n                        debugprintf(\"set : env.mode = %d\\r\\n\", k);\n                        break;\n                }\n            }\n        }\n        else if ( (!strncmp( args[2], \"shock\", 5)) ||\n             (!strncmp( args[2], \"shk\", 3)) )\n        {\n            if (argc<4)\n            {\n                debugstring (\"  ex) set env shock(shk) [value]\\r\\n\");\n                return;\n            }\n            {\n                int k = atoi(args[3]);\n                //switch(k)\n                {\n                    env.ref_shock = k;\n                    debugprintf(\"set : env.ref_shock = %d\\r\\n\", k);\n                    //break;\n                }\n            }\n        }\n        else if ( (!strncmp( args[2], \"port\", 4)) /* || (!strncmp( args[2], \"shk\", 3)) */)\n        {\n            if (argc<4)\n            {\n                debugstring (\"  ex) set env port [value]\\r\\n\");\n                return;\n            }\n            {\n                int k = atoi(args[3]);\n                //switch(k)\n                {\n                    env.port = k;\n                    debugprintf(\"set : env.port = %04d\\r\\n\", k);\n                    //break;\n                }\n            }\n        }\n        else if ( (!strncmp( args[2], \"id\", 2)) /* || (!strncmp( args[2], \"shk\", 3)) */)\n        {\n            if (argc<4)\n            {\n                debugstring (\"  ex) set env id [value]\\r\\n\");\n                return;\n            }\n            {\n                int k = atoi(args[3]);\n                //switch(k)\n                {\n                    env.id = k;\n                    debugprintf(\"set : env.id = %03d\\r\\n\", k);\n                    //break;\n                }\n            }\n        }\n        else if ( (!strncmp( args[2], \"ip\", 2)) /* || (!strncmp( args[2], \"shk\", 3)) */)\n        {\n            if (argc<4)\n            {\n                debugstring (\"  ex) set env ip [xxx.xxx.xxx.xxx]\\r\\n\");\n                return;\n            }\n            {\n                //int k = atoi(args[3]);\n                //switch(k)\n                {\n                    strcpy(env.ip, args[3]);\n                    debugprintf(\"set : env.ip = %s\\r\\n\", args[3]);\n                    //break;\n                }\n            }\n        }\n\n    }\n    else if ( (!strncmp( args[1], \"sensor\", 5)) ||\n         (!strncmp( args[1], \"s\", 1)) )\n    {\n        char s_id = '0';\n        char c_code = '1';\n\n        if (argc<4)\n        {\n            debugstring (\"  ex) set sensor s_no control_no\\r\\n\");\n            return;\n        }\n        else\n        {\n            s_id = args[2][0];\n            c_code = args[3][0];\n\n            switch(s_id)\n            {\n                case '0':\n                case '1':\n                case '2':\n                case '3':\n                case '4':\n                case '5':\n                case '6':\n                case '7':\n                case '8':\n                case '9':\n                case 'A':\n                case 'B':\n                case 'C':\n                case 'D':\n                case 'E':\n                case 'F':\n                case 'R':\n                    switch(c_code)\n                    {\n                        case '0':\n                        case '1':\n                        case '2':\n                            // ctrl_sensor(s_id, c_code);\n                            // ctrl_sensor_set_env(s_id, c_code);\n                            debugprintf(\"sensor control (%c, %c)\\r\\n\", s_id, c_code);\n                            break;\n                    }\n                    break;\n            }\n        }\n    }\n\n}\n\nstatic void cmd_rtc(void)\n{\n    if (argc<2)\n    {\n        debugstring (\"  rtc <arg...>\\r\\n\");\n        return;\n    }\n\n    // INIT\n    if ( (!strncmp( args[1], \"init\", 4)))\n    {\n        debugprintf(\"rtcc init..\\r\\n\");\n        ini_rtcc();\n        ini_time();\n    }\n    // PRINT\n    else if ( (!strncmp( args[1], \"print\", 5)) ||\n              (!strncmp( args[1], \"pr\", 2)))\n    {\n        printTimeTag();\n    }\n    else if ( (!strncmp( args[1], \"sync\", 4)) )\n    {\n        set_rtc_sysclk_sync_req(1);\n    }\n    // SETTIME\n    else if ( (!strncmp( args[1], \"settime\", 6)) ||\n              (!strncmp( args[1], \"st\", 2)))\n    {\n        rtcTime t1;\n\n        t1.year = 2000+atoi(args[2]);\n        t1.mon = atoi(args[3]);\n        t1.day = atoi(args[4]);\n        t1.hour = atoi(args[5]);\n        t1.min = atoi(args[6]);\n        t1.sec = atoi(args[7]);\n\n        debugstring(\"set time\\r\\n\");\n        rtc_settime(&t1);\n        printTimeTag();\n    }\n}\n\nstatic void cmd_chdir(void)\n{\n    //float offset = 0;\n    //float tmp = 0;\n    char buf[21];\n    if (argc<2)\n    {\n        debugstring (\"  chdir <arg...>\\r\\n\");\n        return;\n    }\n\n    debugprintf(\"\\r\\nchdir : %s\", args[1]);\n    f_chdir(args[1]);\n    f_getcwd(buf,20);\n    debugprintf(\"\\r\\n%s\", buf);\n}\n\n\nstatic void cmd_del(void)\n{\n    //float offset = 0;\n    //float tmp = 0;\n    //char buf[21];\n    if (argc<2)\n    {\n        debugstring (\"  del <arg...>\\r\\n\");\n        return;\n    }\n\n    debugprintf(\"\\r\\ndel : %s\", args[1]);\n    f_unlink(args[1]);\n    // f_getcwd(buf,20);\n    // debugprintf(\"\\r\\n%s\", buf);\n}\n\nchar* readfile(char* fname,int* len)\n{\n    FIL fp;\n    int size;\n    char* pngbuf;\n    U32 nRead;\n    FRESULT res = f_open(&fp,fname,FA_READ|FA_OPEN_EXISTING);\n    if( res != FR_OK )\n    {\n        debugprintf(\"Cannot open : %s\\r\\n\", fname);\n        return 0;\n    }\n    size = f_size(&fp);\n    pngbuf=malloc(size);\n    if(pngbuf==0)\n        return 0;\n    f_read(&fp,pngbuf,size,&nRead);\n    f_close(&fp);\n    *len=size;\n    return pngbuf;\n}\n\n\nu8 cat_fid = 0;\nu8 cat_next = 0;\n\nstatic void cmd_bak(void)\n{/*\n    if (argc<2)\n    {\n        cat_next= 1;\n    }\n    else\n    {\n        // u32 param = 99;\n        cat_fid = atoi(args[1]);\n        debugprintf(\"cat_fid = %d\\r\\n\", cat_fid);\n        // if (param == 0)\n        // {\n        //     cat_fid = 0;\n        // }\n    }\n*/}\n\n\nstatic void cmd_cat(void)\n{\n    // cat 1:mo<CR>\n    {\n        FRESULT  res;\n        FIL fp;\n\n        char t_item[100];\n        char buf[1000*210];\n        int len;\n        char *c;\n\n        int fileSize;\n        int nRead;\n        //int i;\n        int position = 0;\n        //int tmp_idx = 0;\n\n        //int a_position = 0;\n        int a_blockSize = 50;\n\n        debugprintf(\"argc(%d)\\r\\n\", argc);\n        debugprintf(\"args[1](%s), [2](%s), [3](%s)\\r\\n\", args[1], args[2], args[3]);\n\n        // start position\n        if (argc > 3)\n        {\n            // debugprintf(\"args[3](%s)\\r\\n\", args[3]);\n            a_blockSize = atoi(args[3]);\n            debugprintf(\"a_blockSize( %d )\\r\\n\", a_blockSize);\n        }\n        if (a_blockSize <= 0)\n        {\n            //error\n            // debugprintf(\"error : a_blockSize( %d )\\r\\n\", a_blockSize);\n            wifiprintf(\"error : a_blockSize( %d )\\r\\n\", a_blockSize);\n            return;\n        }\n        else if (a_blockSize > 200)\n        {\n            //error\n            // debugprintf(\"error : a_blockSize is too big( %d )\\r\\n\", a_blockSize);\n            wifiprintf(\"error : a_blockSize is too big( %d )\\r\\n\", a_blockSize);\n            return;\n        }\n        // debugprintf(\"a_blockSize( %d )\\r\\n\", a_blockSize);\n        // wifiprintf(\"a_blockSize( %d )\\r\\n\", a_blockSize);\n\n\n\n        if (argc < 3)\n        {\n            position = 0;\n        }\n        else\n        {\n            position = (atoi(args[2]) * (1000*a_blockSize));\n        }\n        // debugprintf(\"position( %d )\\r\\n\", position);\n        // wifiprintf(\"position( %d )\\r\\n\", position);\n\n        c = &buf[0];\n        sprintf(t_item,\"1:%s_EB.TXT\",args[1]);\n        // debugprintf(\"t_item(%s)\\r\\n\",t_item);\n        // wifiprintf(\"t_item(%s)\\r\\n\",t_item);\n\n        res = f_open(&fp,t_item, FA_READ|FA_OPEN_EXISTING);   //delayms(5);\n        if (res != FR_OK)\n        {\n            // debugprintf(\"faild f_open(%s) : res : %d\\r\\n\",t_item, res);\n            wifiprintf(\"faild f_open(%s) : res : %d\\r\\n\",t_item, res);\n            return;\n        }\n\n        fileSize = f_size(&fp);\n        // debugprintf(\"fileSize( %d )\\r\\n\", fileSize);\n        // wifiprintf(\"fileSize( %d )\\r\\n\", fileSize);\n\n        // position = a_position;\n\n        if (position >= fileSize)\n        {\n            // debugprintf(\"error: fileSize(%d) is less than start position(%d)\\r\\n\", fileSize, position);\n            wifiprintf(\"error: fileSize(%d) is less than start position(%d)\\r\\n\", fileSize, position);\n            return;\n        }\n#if 1\n        if (fileSize == ((1000*a_blockSize)+position) )\n        {\n\n        }\n        if (fileSize > ((1000*a_blockSize)+position) )\n        {\n            len = (1000*a_blockSize);\n            // position = ((1000*50)+a_position);\n        }\n        else\n        {\n            len = fileSize - position;\n            // position = 0;\n        }\n#else\n\n        //----------------------20141013---\n        a_blockSize = 20;\n\n        // if (fileSize == ((1000*a_blockSize)) )\n        // {\n\n        // }\n        if (fileSize >= ((1000*a_blockSize)) )\n        {\n            len = (1000*a_blockSize);\n            position = fileSize - len;\n            // position = ((1000*50)+a_position);\n        }\n        else\n        {\n            len = fileSize;\n            position = 0;\n        }\n#endif\n        f_lseek(&fp, position);   //delayms(5);\n\n        f_read(&fp,c,len,&nRead);\n        f_close(&fp);\n\n        buf[len]='\\0';\n\n\n        sprintf(t_item,\"%06d\",len);\n\n        // debugprintf(\"len( %d ), nRead( %d )\\r\\n\", len, nRead);\n        // wifiprintf(\"len( %d ), nRead( %d )\\r\\n\", len, nRead);\n        // debugstring(buf);\n        wifistring(t_item);\n        wifistring(buf);\n\n    }\n}\n\n\nvoid Task_cat(void)\n{/*\n    static u32 idx=0;\n    static u32 position=0;\n    static u32 blockSize=5;\n    static u32 count=10;\n    static char buf[5000+1];\n\n    // int fileSize;\n\n    switch (idx)\n    {\n        case 0:\n            if (cat_fid > 0 )\n            {\nPRINTLINE;\n                position = 0;\n                count=10;\n                idx = 50;\n            }\n            break;\n\n        case 50:\n            switch (cat_fid)\n            {\n                case 1:\n                    {\nPRINTLINE;\n                        // ai.dat\n                        FRESULT  res;\n                        FIL fp;\n                        int nRead;\n                        char *c;\n                        char t_item[20];\n                        u32 len = 1000;\n\n                        c = &buf[0];\n\n                        strcpy(t_item, \"1:mo.dat\");\n                        res = f_open(&fp,t_item, FA_READ|FA_OPEN_EXISTING);   //delayms(5);\n                        if (res != FR_OK)\n                        {\n                            wifiprintf(\"faild f_open(%s) : res : %d\\r\\n\",t_item, res);\n                            cat_fid = 0;\n                            idx = 0;\n                        }\n                        else\n                        {\n\n                            f_lseek(&fp, position);   //delayms(5);\n\n                            f_read(&fp, c, len, &nRead);\n                            f_close(&fp);\n\n                            buf[len]='\\0';\n\n                            position += nRead;\n                            idx = 100;\n                        }\n                    }\n                    break;\n                default:\n                    idx = 0;\n                    break;\n            }\n            break;\n\n        case 100:\nPRINTLINE;\n            wifiprintf(buf);\n            idx = 150;\n            tick_cat = 10;\n            break;\n\n        case 150:\n            // if (cat_next==1)\n            if (tick_cat==0)\n            {\n                cat_next = 0;\n                idx=50;\nPRINTLINE;\n           if (--count==0)\n           {\n               idx = 0;\n               cat_fid = 0;\n           }\n        }\n            break;\n\n    }\n*/}\n\n\n\nstatic void cmd_fs(void)\n{\n    if (argc<2)\n    {\n        debugstring (\"  fs <arg...>\\r\\n\");\n        return;\n    }\n\n    // ls, ll - list files in current folder.\n    if ( (!strncmp( args[1], \"ls\", 2)) ||\n         (!strncmp( args[1], \"ll\", 2)))\n    {\n        switch (argc)\n        {\n            case 2:\n                print_files (\"1:\");\n                break;\n            case 3:\n                {\n                    // print_files (\"1:\");\n                    char buf[30];\n\n                    sprintf(buf,\"1:/%s\",args[2]);\n                    // print_files (args[2]);\n                    print_files (buf);\n                }\n                break;\n        }\n    }\n\n    else if ( (!strncmp( args[1], \"clear\", 5)) ||\n              (!strncmp( args[1], \"clr\"  , 3)))\n    {\n        sdc_unmount();\n        sdc_clear(); \n    }\n\n\n    // cpsr cp_sr - copy file from SD to RAM\n    else if ( (!strncmp( args[1], \"cp_sr\", 5)) ||\n              (!strncmp( args[1], \"cpsr\", 4)))\n    {\n        FRESULT  res;\n        FIL fp;\n\n        char t_item[100];\n        char buf[1024*512];\n        int len;\n        char *c;\n\n        int fileSize;\n        int nRead;\n        int i;\n        int position = 0;\n        int tmp_idx = 0;\n\n        c = &buf[0];\n        strcpy(t_item,\"1:boot.bin\");\n        debugprintf(\"t_item(%s)\\r\\n\",t_item);\n\nPRINTLINE;\n\n        res = f_open(&fp,t_item, FA_READ|FA_OPEN_EXISTING);   delayms(5);\n        if (res != FR_OK)\n        {\n            debugprintf(\"faild f_open(%s) : res : %d\\r\\n\",t_item, res);\n            return;\n        }\n\n        fileSize = f_size(&fp);\n        debugprintf(\"fileSize( %d )\\r\\n\", fileSize);\n\nPRINTLINE;\n\n        while (1)\n        {\n            if (fileSize >1024)\n            {\n                len = 1024;\n                position += 1024;\n            }\n            else\n            {\n                len = fileSize;\n                position += fileSize;\n            }\n            f_read(&fp,c,len,&nRead);\n            c += nRead;\n            f_lseek(&fp, position);   //delayms(5);\n\n            debugprintf(\"len( %d ), nRead( %d )\\r\\n\", len, nRead);\n            debugprintf(\"[%04X] \", tmp_idx);\n            for (i = 0; i < 16; ++i)\n            {\n                debugprintf(\"%02X \", (u8)buf[tmp_idx+i]);\n            }\n            debugstring(\"\\r\\n\");\n            tmp_idx += nRead;\n\n            fileSize -= nRead;\n            debugprintf(\"remain fileSize( %d )\\r\\n\", fileSize);\n\n            if ( fileSize <= 0 )\n            {\n                break;\n            }\n        }\n\nPRINTLINE;\n\n        f_close(&fp);\n\n        //debugprintf(\"size( %d ), nRead( %d )\\r\\n\", size, nRead);\n\nPRINTLINE;\n\n        // *len=size;\n        //return pngbuf;\n\n        // //f_lseek(fp, (fp->fsize));   delayms(5);\n        // sz_msg = strlen(a_msg);\n        // f_write(fp, a_msg, sz_msg, &bw);   delayms(5);\n\n        // *fsz = (u32)(fp->fsize);\n        // f_close(fp);   delayms(5);\n\n\n    }\n\n    else if ( (!strncmp( args[1], \"ai\", 2)) ||\n              (!strncmp( args[1], \"ct\", 2)) ||\n              (!strncmp( args[1], \"zp\", 2)) ||\n              (!strncmp( args[1], \"t1\", 2)) ||\n              (!strncmp( args[1], \"t2\", 2)) ||\n              (!strncmp( args[1], \"hm\", 2)) ||\n              (!strncmp( args[1], \"pt\", 2)) ||\n              (!strncmp( args[1], \"sh\", 2)) ||\n              (!strncmp( args[1], \"gp\", 2)) ||\n              (!strncmp( args[1], \"mo\", 2)) ||\n              (!strncmp( args[1], \"se\", 2))\n        )\n    {\n        FRESULT  res;\n        FIL fp;\n\n        char t_item[100];\n        char buf[1024*4];\n        int len;\n        char *c;\n\n        int fileSize;\n        int nRead;\n        //int i;\n        int position = 0;\n        //int tmp_idx = 0;\n\n        c = &buf[0];\n        sprintf(t_item,\"1:%s.dat\",args[1]);\n        // strcpy(t_item,\"1:ai.dat\");\n        debugprintf(\"t_item(%s)\\r\\n\",t_item);\n\n        res = f_open(&fp,t_item, FA_READ|FA_OPEN_EXISTING);   //delayms(5);\n        if (res != FR_OK)\n        {\n            debugprintf(\"faild f_open(%s) : res : %d\\r\\n\",t_item, res);\n            return;\n        }\n\n        fileSize = f_size(&fp);\n        debugprintf(\"fileSize( %d )\\r\\n\", fileSize);\n\n        if (fileSize >(1024*1)-1)\n        {\n            len = (1024*1)-1;\n            position = fileSize - (1024*1)-1;\n        }\n        else\n        {\n            len = fileSize;\n            position = 0;\n        }\n\n        f_lseek(&fp, position);   //delayms(5);\n\n        f_read(&fp,c,len,&nRead);\n        f_close(&fp);\n\n        buf[len]='\\0';\n\n        debugprintf(\"len( %d ), nRead( %d )\\r\\n\", len, nRead);\n        debugstring(buf);\n\n    }\n\n    // cpsw cp_sw - copy file from SD to WiFi\n    else if ( (!strncmp( args[1], \"cp_sw\", 5)) ||\n              (!strncmp( args[1], \"cpsw\", 4)))\n    {\n        print_files (\"1:\");\n    }\n    // cprs cp_rs - copy file from RAM to SD\n    else if ( (!strncmp( args[1], \"cp_rs\", 5)) ||\n              (!strncmp( args[1], \"cprs\", 4)))\n    {\n        FRESULT  res;\n        FIL fp;\n\n        char t_item[100];\n        char buf[1024*512];\n        int len;\n        char *c;\n\n        int fileSize, fileSize_bak;\n        int nRead;\n        int nWrite;\n        int i;\n        int position = 0;\n        int tmp_idx = 0;\n\n        c = &buf[0];\n        strcpy(t_item,\"1:boot.bin\");\n        debugprintf(\"t_item(%s)\\r\\n\",t_item);\n\nPRINTLINE;\n\n        res = f_open(&fp,\"1:boot.bin\", FA_READ|FA_OPEN_EXISTING);   delayms(5);\n        if (res != FR_OK)\n        {\n            debugprintf(\"faild f_open(%s) : res : %d\\r\\n\",t_item, res);\n            return;\n        }\n\n        fileSize_bak = fileSize = f_size(&fp);\n        debugprintf(\"fileSize( %d )\\r\\n\", fileSize);\n\nPRINTLINE;\n\n        while (1)\n        {\n            if (fileSize >1024)\n            {\n                len = 1024;\n                position += 1024;\n            }\n            else\n            {\n                len = fileSize;\n                position += fileSize;\n            }\n            f_read(&fp,c,len,&nRead);\n            c += nRead;\n            f_lseek(&fp, position);   //delayms(5);\n\n            debugprintf(\"len( %d ), nRead( %d )\\r\\n\", len, nRead);\n            debugprintf(\"[%04X] \", tmp_idx);\n            for (i = 0; i < 16; ++i)\n            {\n                debugprintf(\"%02X \", (u8)buf[tmp_idx+i]);\n            }\n            debugstring(\"\\r\\n\");\n            tmp_idx += nRead;\n\n            fileSize -= nRead;\n            debugprintf(\"remain fileSize( %d )\\r\\n\", fileSize);\n\n            if ( fileSize <= 0 )\n            {\n                break;\n            }\n        }\n\nPRINTLINE;\n\n        f_close(&fp);\n        debugstring(\"close file : boot.bin\\r\\n\");\n\nPRINTLINE;\n\n        debugstring(\"open file : boot1.bin\\r\\n\");\n        res = f_open(&fp,\"1:boot1.bin\", FA_WRITE|FA_OPEN_ALWAYS);   delayms(5);\n        if (res != FR_OK)\n        {\n            debugprintf(\"faild f_open(%s) : res : %d\\r\\n\",t_item, res);\n            return;\n        }\n\n        fileSize = fileSize_bak;    //tmp_idx;\nPRINTVAR(fileSize);\n        position = 0;\n\nPRINTLINE;\n        while (1)\n        {\n            // debugprintf(\"fp.fsize(%d)\\r\\n\",fp.fsize);\nPRINTVAR(fp.fsize);\n            f_lseek(&fp, (fp.fsize));   //delayms(5);\n            if (fileSize >1024)\n            {\n                len = 1024;\n                fileSize -= 1024;\n                f_write(&fp, (buf+position), len, &nWrite);   //delayms(5);\n                position += 1024;\n                debugprintf(\"write(%d)\\r\\n\",position);\n            }\n            else\n            {\n                len = fileSize;\n                fileSize -= len;\n                f_write(&fp, (buf+position), len, &nWrite);   //delayms(5);\n                position += fileSize;\n                debugprintf(\"write(%d)\\r\\n\",position);\n                break;\n            }\n        }\n\n        f_close(&fp);   //delayms(5);\n        debugstring(\"close file : boot1.bin\\r\\n\");\n        return;\n    }\n\n    // cprf cp_rf - copy file from RAM to FLASH\n    else if ( (!strncmp( args[1], \"cp_rf\", 5)) ||\n              (!strncmp( args[1], \"cprf\", 4)))\n    {\n        print_files (\"1:\");\n    }\n\n    // cpss cp_ss - copy file from SD to SD\n    else if ( (!strncmp( args[1], \"cp_ss\", 5)) ||\n              (!strncmp( args[1], \"cpss\", 4)))\n    {\n        FRESULT  res;\n        FIL fp;\n\n        char t_item[100];\n        char buf[1024*512];\n        int len;\n        char *c;\n\n        int fileSize, fileSize_bak;\n        int nRead;\n        int nWrite;\n        int i;\n        int position = 0;\n        int tmp_idx = 0;\n\n        c = &buf[0];\n        strcpy(t_item,\"1:boot.bin\");\n        debugprintf(\"t_item(%s)\\r\\n\",t_item);\n\nPRINTLINE;\n\n        res = f_open(&fp,\"1:boot.bin\", FA_READ|FA_OPEN_EXISTING);   delayms(5);\n        if (res != FR_OK)\n        {\n            debugprintf(\"faild f_open(%s) : res : %d\\r\\n\",t_item, res);\n            return;\n        }\n\n        fileSize_bak = fileSize = f_size(&fp);\n        debugprintf(\"fileSize( %d )\\r\\n\", fileSize);\n\nPRINTLINE;\n\n        while (1)\n        {\n            if (fileSize >1024)\n            {\n                len = 1024;\n                position += 1024;\n            }\n            else\n            {\n                len = fileSize;\n                position += fileSize;\n            }\n            f_read(&fp,c,len,&nRead);\n            c += nRead;\n            f_lseek(&fp, position);   //delayms(5);\n\n            debugprintf(\"len( %d ), nRead( %d )\\r\\n\", len, nRead);\n            debugprintf(\"[%04X] \", tmp_idx);\n            for (i = 0; i < 16; ++i)\n            {\n                debugprintf(\"%02X \", (u8)buf[tmp_idx+i]);\n            }\n            debugstring(\"\\r\\n\");\n            tmp_idx += nRead;\n\n            fileSize -= nRead;\n            debugprintf(\"remain fileSize( %d )\\r\\n\", fileSize);\n\n            if ( fileSize <= 0 )\n            {\n                break;\n            }\n        }\n\nPRINTLINE;\n\n        f_close(&fp);\n        debugstring(\"close file : boot.bin\\r\\n\");\n\nPRINTLINE;\n\n        debugstring(\"open file : boot1.bin\\r\\n\");\n        res = f_open(&fp,\"1:boot1.bin\", FA_WRITE|FA_OPEN_ALWAYS);   delayms(5);\n        if (res != FR_OK)\n        {\n            debugprintf(\"faild f_open(%s) : res : %d\\r\\n\",t_item, res);\n            return;\n        }\n\n        fileSize = fileSize_bak;    //tmp_idx;\nPRINTVAR(fileSize);\n        position = 0;\n\nPRINTLINE;\n        while (1)\n        {\n            // debugprintf(\"fp.fsize(%d)\\r\\n\",fp.fsize);\nPRINTVAR(fp.fsize);\n            f_lseek(&fp, (fp.fsize));   //delayms(5);\n            if (fileSize >1024)\n            {\n                len = 1024;\n                fileSize -= 1024;\n                f_write(&fp, (buf+position), len, &nWrite);   //delayms(5);\n                position += 1024;\n                debugprintf(\"write(%d)\\r\\n\",position);\n            }\n            else\n            {\n                len = fileSize;\n                fileSize -= len;\n                f_write(&fp, (buf+position), len, &nWrite);   //delayms(5);\n                position += fileSize;\n                debugprintf(\"write(%d)\\r\\n\",position);\n                break;\n            }\n        }\n\n        f_close(&fp);   //delayms(5);\n        debugstring(\"close file : boot1.bin\\r\\n\");\n        return;\n    }\n\n    // cpsf cp_sf - copy file from SD to FLASH\n    else if ( (!strncmp( args[1], \"cp_sf\", 5)) ||\n              (!strncmp( args[1], \"cpsf\", 4)))\n    {\n        FRESULT  res;\n        FIL fp;\n\n        char t_item[100];\n        char buf[1024*512];\n        int len;\n        char *c;\n\n        int fileSize, fileSize_bak;\n        int nRead;\n        //int nWrite;\n        int i;\n        int position = 0;\n        int tmp_idx = 0;\n\n        c = &buf[0];\n        strcpy(t_item,\"1:boot.bin\");\n        debugprintf(\"t_item(%s)\\r\\n\",t_item);\n\nPRINTLINE;\n\n        res = f_open(&fp,\"1:boot.bin\", FA_READ|FA_OPEN_EXISTING);   delayms(5);\n        if (res != FR_OK)\n        {\n            debugprintf(\"faild f_open(%s) : res : %d\\r\\n\",t_item, res);\n            return;\n        }\n\n        fileSize_bak = fileSize = f_size(&fp);\n        debugprintf(\"fileSize( %d )\\r\\n\", fileSize);\n\nPRINTLINE;\n\n        while (1)\n        {\n            if (fileSize >1024)\n            {\n                len = 1024;\n                position += 1024;\n            }\n            else\n            {\n                len = fileSize;\n                position += fileSize;\n            }\n            f_read(&fp,c,len,&nRead);\n            c += nRead;\n            f_lseek(&fp, position);   //delayms(5);\n\n            debugprintf(\"len( %d ), nRead( %d )\\r\\n\", len, nRead);\n            debugprintf(\"[%04X] \", tmp_idx);\n            for (i = 0; i < 16; ++i)\n            {\n                debugprintf(\"%02X \", (u8)buf[tmp_idx+i]);\n            }\n            debugstring(\"\\r\\n\");\n            tmp_idx += nRead;\n\n            fileSize -= nRead;\n            debugprintf(\"remain fileSize( %d )\\r\\n\", fileSize);\n\n            if ( fileSize <= 0 )\n            {\n                break;\n            }\n        }\n\nPRINTLINE;\n\n        f_close(&fp);\n        debugstring(\"close file : boot.bin\\r\\n\");\n\n        //--------------------------------------------------\n\n        {\n            //extern const unsigned int bootloader_trip_elf_bin_len;\n            int i;\n            // int sectors = bootloader_trip_elf_bin_len/flash_get_sectorsize();\n            int sectors = fileSize_bak/flash_get_sectorsize();\n            // if(bootloader_trip_elf_bin_len % flash_get_sectorsize())\n            if(fileSize_bak % flash_get_sectorsize())\n                sectors++;\n            debugprintf(\"erase bootloader sectors...\\r\\n\");\n            for(i=20;i<(sectors+20);i++)\n            {\n                debugprintf(\"%d sector\\r\\n\",i);\n                flash_erase_sector(i,1);\n            }\n            debugstring(\"update....\\r\\n\");\n            // flash_write(0,(BYTE*)bootloader_trip_elf_bin,bootloader_trip_elf_bin_len);\n            flash_write(0x14000,(BYTE*)buf,fileSize_bak);\n            debugstring(\"completed\\r\\n\");\n\n        }\n\n\n// PRINTLINE;\n\n//         debugstring(\"open file : boot1.bin\\r\\n\");\n//         res = f_open(&fp,\"1:boot1.bin\", FA_WRITE|FA_OPEN_ALWAYS);   delayms(5);\n//         if (res != FR_OK)\n//         {\n//             debugprintf(\"faild f_open(%s) : res : %d\\r\\n\",t_item, res);\n//             return;\n//         }\n\n//         fileSize = fileSize_bak;    //tmp_idx;\n// PRINTVAR(fileSize);\n//         position = 0;\n\n// PRINTLINE;\n//         while (1)\n//         {\n//             // debugprintf(\"fp.fsize(%d)\\r\\n\",fp.fsize);\n// PRINTVAR(fp.fsize);\n//             f_lseek(&fp, (fp.fsize));   //delayms(5);\n//             if (fileSize >1024)\n//             {\n//                 len = 1024;\n//                 fileSize -= 1024;\n//                 f_write(&fp, (buf+position), len, &nWrite);   //delayms(5);\n//                 position += 1024;\n//                 debugprintf(\"write(%d)\\r\\n\",position);\n//             }\n//             else\n//             {\n//                 len = fileSize;\n//                 fileSize -= len;\n//                 f_write(&fp, (buf+position), len, &nWrite);   //delayms(5);\n//                 position += fileSize;\n//                 debugprintf(\"write(%d)\\r\\n\",position);\n//                 break;\n//             }\n//         }\n\n//         f_close(&fp);   //delayms(5);\n//         debugstring(\"close file : boot1.bin\\r\\n\");\n        return;\n    }\n}\n\n\nstatic void cmd_gps(void)\n{\n    set_gps_rawdata_display();\n}\n\nstatic void cmd_alti(void)\n{\n    set_alti_rawdata_display();\n}\n\nstatic void cmd_sec(void)\n{\n    set_secData_display();\n}\nstatic void cmd_min(void)\n{\n    set_minData_display();\n}\n\n\nstatic void cmd_get(void)\n{\n    //char buf[21];\n    if (argc<2)\n    {\n        return;\n    }\n\n    if ( (!strncmp( args[1], \"bat\", 3)))\n    {\n        measure_BAT_leval();\n        //debugprintf(\"bat : %03d\\r\\n\", get_battery_level());\n    }\n}\n\nvoid App_TestShInit ()\n{\n\n	//debugstring(\"\\r\\nTestShell init\\r\\n\");\n	//testSh_RegisterCmd (\"exit\", NULL, \"exit --- exit test tool\\n\");					// 0\n	testSh_RegisterCmd (\"help\", cmd_help, \"help --- show available commands\\n\");		// 1\n	//testSh_RegisterCmd (\"hex\", NULL, \"hex --- command line radix hexa\\n\");			// 2\n	//testSh_RegisterCmd (\"dec\", NULL, \"dec --- command line radix decimal\\n\");		// 3\n\n    // testSh_RegisterCmd (\"at\", cmd_at,    \"temp command aa\\r\\n\"); //\n    testSh_RegisterCmd (\"mv\", cmd_mv,    \"temp command aa\\r\\n\"); //\n    testSh_RegisterCmd (\"gps\", cmd_gps,  \"toggle GPS sensor data.\\r\\n\"); //\n    testSh_RegisterCmd (\"alti\",cmd_alti, \"toggle ALTI sensor data.\\r\\n\"); //\n    testSh_RegisterCmd (\"sec\", cmd_sec,  \"toggle SEC data.\\r\\n\"); //\n    testSh_RegisterCmd (\"min\", cmd_min,  \"toggle MIN data.\\r\\n\"); //\n\n    testSh_RegisterCmd (\"chdir\", cmd_chdir,  \"sdc: chdir\\r\\n\"); //\n    // testSh_RegisterCmd (\"dd\", cmd_dd,    \"temp command dd\\r\\n\"); //\n    // testSh_RegisterCmd (\"bak\", cmd_bak,    \"temp command ee\\r\\n\"); //\n    testSh_RegisterCmd (\"env\", cmd_env,  \"env [save init read print]\\r\\n\"); //\n    // testSh_RegisterCmd (\"msg\", cmd_msg,  \"msg\\r\\n\"); //\n    // testSh_RegisterCmd (\"ts\", cmd_ts,    \"ATM timesync test\\r\\n\"); //\n    testSh_RegisterCmd (\"fs\", cmd_fs,    \"command file system\\r\\n\"); //\n    testSh_RegisterCmd (\"cat\", cmd_cat,    \"command file system\\r\\n\"); //\n    testSh_RegisterCmd (\"del\", cmd_del,    \"command file delete\\r\\n\"); //\n    // testSh_RegisterCmd (\"gg\", cmd_gg,    \"temp command gg\\r\\n\"); //\n    // testSh_RegisterCmd (\"mm\", cmd_mm,    \"temp command mm\\r\\n\"); //\n    // testSh_RegisterCmd (\"qq\", cmd_qq,    \"temp command qq\\r\\n\"); //\n    // testSh_RegisterCmd (\"rr\", cmd_rr,    \"temp command rr\\r\\n\"); //\n    // testSh_RegisterCmd (\"ss\", cmd_ss,    \"temp command ss\\r\\n\"); //\n    // testSh_RegisterCmd (\"tt\", cmd_tt,    \"temp command tt\\r\\n\"); //\n    // testSh_RegisterCmd (\"uu\", cmd_uu,    \"temp command uu\\r\\n\"); //\n    // testSh_RegisterCmd (\"vv\", cmd_vv,    \"temp command vv\\r\\n\"); //\n    // testSh_RegisterCmd (\"ww\", cmd_ww,    \"temp command ww\\r\\n\"); //\n    // testSh_RegisterCmd (\"xx\", cmd_xx,    \"temp command xx\\r\\n\"); //\n    // testSh_RegisterCmd (\"yy\", cmd_yy,    \"temp command yy\\r\\n\"); //\n    // testSh_RegisterCmd (\"zz\", cmd_zz,    \"temp command zz\\r\\n\"); //\n    // testSh_RegisterCmd (\"sbr\", cmd_sbr,  \"sb16c1058 get reg, sbr ch regno\\r\\n\"); //\n    // testSh_RegisterCmd (\"sbw\", cmd_sbw,  \"sb16c1058 set reg, sbr ch regno data\\r\\n\"); //\n    testSh_RegisterCmd (\"set\", cmd_set,  \"set [heartbeat(hb)]\\r\\n\"); //\n	testSh_RegisterCmd (\"get\", cmd_get,  \"get [bat]\\r\\n\"); //\n    // testSh_RegisterCmd (\"pos\", cmd_pos,  \"pos --- position distance calc.\\r\\n\");\n    testSh_RegisterCmd (\"rtc\", cmd_rtc,  \"rtc --- rtc .\\r\\n\");\n    // testSh_RegisterCmd (\"sh\",  cmd_sh,   \"sh  --- sht11 port ctrl test.\\r\\n\");\n    // testSh_RegisterCmd (\"syscmd\", cmd_syscmd,     \"syscmd --- sensor control command\\r\\n\");\n}\n\n\n",
			"file": "source/k_cli.c",
			"file_size": 70911,
			"file_write_time": 130691620514892730,
			"settings":
			{
				"buffer_size": 68263,
				"line_ending": "Windows"
			}
		},
		{
			"file": "SDK2.0/lib_src/serialflash.c",
			"settings":
			{
				"buffer_size": 757,
				"line_ending": "Windows"
			}
		}
	],
	"build_system": "Packages/Python/Python.sublime-build",
	"command_palette":
	{
		"height": 490.0,
		"selected_items":
		[
			[
				"Package Control: ",
				"Package Control: Install Package"
			],
			[
				"pi",
				"Package Control: Install Package"
			],
			[
				"pin",
				"Package Control: Install Package"
			],
			[
				"sublime",
				"Preferences: SublimeLinter Settings – User"
			],
			[
				"sublimelinter",
				"Preferences: SublimeLinter Settings – Default"
			],
			[
				"ca",
				"File: Close All"
			],
			[
				":help",
				"Set Syntax: Shell Script (Bash)"
			],
			[
				":w",
				":w - Save"
			]
		],
		"width": 637.0
	},
	"console":
	{
		"height": 111.0,
		"history":
		[
			"a",
			"a=3",
			"2",
			"ctags -R -f .tags",
			"exit"
		]
	},
	"distraction_free":
	{
		"menu_visible": true,
		"show_minimap": false,
		"show_open_files": false,
		"show_tabs": false,
		"side_bar_visible": false,
		"status_bar_visible": false
	},
	"expanded_folders":
	[
	],
	"file_history":
	[
		"/C/work/projects/210_EchoBuoy/Firmware2/source/k_includes.h",
		"/C/work/projects/210_EchoBuoy/Firmware2/source/k_gps.c",
		"/C/work/projects/210_EchoBuoy/Firmware2/source/startup/trip_board.c",
		"/C/work/projects/210_EchoBuoy/Firmware2/source/k_iridium.c",
		"/C/work/projects/210_EchoBuoy/Firmware2/source/k_sdc.c",
		"/C/work/projects/210_EchoBuoy/Firmware2/source/k_sdc.h",
		"/C/work/projects/210_EchoBuoy/Firmware2/source/k_timer.c",
		"/C/work/projects/210_EchoBuoy/Firmware2/SDK2.0/lib_src/fatfs/ff.c",
		"/C/work/projects/210_EchoBuoy/Firmware2/source/k_ct3919.h",
		"/C/work/projects/210_EchoBuoy/Firmware2/source/k_msg.c",
		"/C/work/projects/210_EchoBuoy/Firmware2/source/k_msg.h",
		"/C/work/projects/210_EchoBuoy/Firmware2/source/k_timer.h",
		"/C/work/projects/210_EchoBuoy/Firmware2/source/k_main.h",
		"/C/work/projects/210_EchoBuoy/Firmware2/source/k_gps.h",
		"/C/work/projects/210_EchoBuoy/Firmware2/source/k_main.c",
		"/C/work/projects/210_EchoBuoy/Firmware2/source/k_cli.c",
		"/C/work/projects/210_EchoBuoy/Firmware2/source/k_sysMCU.c",
		"/C/work/projects/210_EchoBuoy/Firmware2/source/k_misc.c",
		"/C/work/projects/210_EchoBuoy/Firmware2/source/k_cli.h",
		"/C/work/projects/210_EchoBuoy/Firmware2/source/k_ct3919.c",
		"/F/se.dat",
		"/F/gp.dat",
		"/F/ct.dat",
		"/C/work/projects/210_EchoBuoy/Firmware2/source/k_config.h",
		"/C/work/projects/210_EchoBuoy/Firmware2/source/k_iridium.h",
		"/C/work/projects/210_EchoBuoy/Firmware2/SDK2.0/lib_src/uart.c",
		"/C/work/projects/210_EchoBuoy/Firmware2/SDK2.0/include/lib_config.h",
		"/C/work/projects/210_EchoBuoy/Firmware2/SDK2.0/include/adstar/uart.h",
		"/C/Users/kychoX1/Desktop/wm211-150121.log",
		"/C/work/projects/210_EchoBuoy/Firmware2/SDK2.0/lib_src/zlib-1.2.5/compress.c",
		"/C/work/projects/210_EchoBuoy/Firmware2/source/k_main.c.bak",
		"/C/Users/kychoX1/Desktop/teraterm.log",
		"/C/work/projects/210_EchoBuoy/Firmware2/SDK2.0/include/typedef.h",
		"/C/work/projects/210_EchoBuoy/Firmware2/source/k_rtc.c",
		"/C/work/projects/210_EchoBuoy/Firmware2/SDK2.0/include/adstar/watchdogtimer.h",
		"/C/work/projects/210_EchoBuoy/Firmware2/source/buoy_waves2.c",
		"/C/work/projects/210_EchoBuoy/Firmware2/SDK2.0/include/egl/object/egl_progressbar.h",
		"/C/work/projects/210_EchoBuoy/Firmware2/SDK2.0/include/adstar/gpio.h",
		"/C/work/projects/210_EchoBuoy/Firmware2/SDK2.0/include/fatfs/ffconf.h",
		"/C/work/projects/210_EchoBuoy/Firmware2/source/mose/fftpack.c",
		"/C/work/projects/210_EchoBuoy/Firmware2/SDK2.0/lib_src/zlib-1.2.5/FAQ",
		"/C/work/GitHub/Drifter/SDK 1.6/include/cantus/uart.h",
		"/C/Users/kychoX1/Desktop/teraterm - 복사본 (2).log",
		"/C/Users/kychoX1/Desktop/teraterm - 복사본.log",
		"/C/work/projects/210_EchoBuoy/Firmware2/source/k_mose.c",
		"/C/work/projects/900_MCU/adchips/adStar/SDK_v2.0.0/example/WatchDog1/main.c",
		"/C/work/projects/900_MCU/adchips/adStar/SDK_v2.0.0/example/WatchDog2/main.c",
		"/C/work/projects/210_EchoBuoy/Firmware2/SDK2.0/include/adstar.h",
		"/C/Users/kychoX1/AppData/Roaming/Sublime Text 3/Packages/User/Preferences.sublime-settings",
		"/C/work/projects/210_EchoBuoy/Firmware2/source/k_aio.c",
		"/C/work/projects/210_EchoBuoy/Firmware2/SDK2.0/startup/stk_board.c",
		"/E/GitHub/KOGA14/source/k_ct3919.c",
		"/E/GitHub/KOGA14/source/k_main.c",
		"/E/GitHub/KOGA14/source/k_dcs.c",
		"/E/GitHub/KOGA14/source/k_aio.c",
		"/E/GitHub/KOGA14/source/k_main.h",
		"/E/GitHub/KOGA14/source/k_mose.c",
		"/E/GitHub/KOGA14/source/k_sb16c1058.c",
		"/E/GitHub/KOGA14/source/k_config.h",
		"/C/Users/YOUNGKIL/Desktop/W03.log",
		"/C/Users/YOUNGKIL/Desktop/log.log",
		"/E/GitHub/KOGA14/source/k_sb16c1058.h",
		"/E/GitHub/KOGA14/source/obj/k_sb16c1058.d",
		"/C/work/projects/100_KOGA/KOGA14/KOGA2014 설치작업과정 DATA/temp/util/WC_FW/Transfer/bin/Release/mose_101.txt",
		"/E/GitHub/KOGA14/source/k_ct3919.h",
		"/C/work/projects/100_KOGA/KOGA14/KOGA2014 설치작업과정 DATA/KOGA14-지원/Util/Raw Data 받기/mose_001.txt",
		"/E/GitHub/KOGA14/source/k_cli.c",
		"/E/GitHub/KOGA14/source/buoy_waves2.h",
		"/C/work/projects/100_KOGA/KOGA14/KOGA2014 설치작업과정 DATA/temp/util/WC_FW/Transfer/bin/Release/mose_021.txt",
		"/C/work/projects/100_KOGA/KOGA14/KOGA2014 설치작업과정 DATA/temp/util/WC_FW/Transfer/bin/Release/mose_001.txt",
		"/C/work/projects/100_KOGA/KOGA14/KOGA2014 설치작업과정 DATA/temp/util/WC_FW/Transfer/bin/Release/mose_002.txt",
		"/C/work/projects/100_KOGA/KOGA14/KOGA2014 설치작업과정 DATA/temp/util/WC_FW/Transfer/bin/Release/mose_003.txt",
		"/C/work/projects/100_KOGA/KOGA14/KOGA2014 설치작업과정 DATA/temp/util/WC_FW/Transfer/bin/Release/mose_011.txt",
		"/C/work/projects/100_KOGA/KOGA14/KOGA2014 설치작업과정 DATA/temp/util/WC_FW/Transfer/bin/Release/mose_008.txt",
		"/C/work/projects/100_KOGA/KOGA14/KOGA2014 설치작업과정 DATA/temp/util/WC_FW/Transfer/bin/Release/mose_006.txt",
		"/C/work/projects/100_KOGA/KOGA14/KOGA2014 설치작업과정 DATA/2_E01/새 폴더/shock_1411.dat",
		"/C/work/projects/100_KOGA/KOGA14/KOGA2014 설치작업과정 DATA/2_E01/rawData(2013_E01_SDCARD Backup)/sh.dat",
		"/C/work/projects/100_KOGA/KOGA14/KOGA2014 설치작업과정 DATA/2_E01/새 폴더/atm2_1411.dat",
		"/C/work/projects/100_KOGA/KOGA14/KOGA2014 설치작업과정 DATA/2_E01/rawData(2013_E01_SDCARD Backup)/t2.dat",
		"/C/work/projects/100_KOGA/KOGA14/KOGA2014 설치작업과정 DATA/2_E01/새 폴더/send_1411.dat",
		"/C/work/projects/100_KOGA/KOGA14/KOGA2014 설치작업과정 DATA/2_E01/rawData(2013_E01_SDCARD Backup)/se.dat",
		"/C/work/projects/100_KOGA/KOGA14/KOGA2014 설치작업과정 DATA/2_E01/새 폴더/history_1411.dat",
		"/C/work/projects/100_KOGA/KOGA14/KOGA2014 설치작업과정 DATA/2_E01/rawData(2013_E01_SDCARD Backup)/hi.dat",
		"/C/work/projects/100_KOGA/KOGA14/KOGA2014 설치작업과정 DATA/2_E01/새 폴더/pt100_1411.dat",
		"/C/work/projects/100_KOGA/KOGA14/KOGA2014 설치작업과정 DATA/2_E01/rawData(2013_E01_SDCARD Backup)/pt.dat",
		"/C/work/projects/100_KOGA/KOGA14/KOGA2014 설치작업과정 DATA/2_E01/rawData(2013_E01_SDCARD Backup)/gp.dat",
		"/C/work/projects/100_KOGA/KOGA14/KOGA2014 설치작업과정 DATA/2_E01/새 폴더/gps_1411.dat",
		"/C/work/projects/100_KOGA/KOGA14/KOGA2014 설치작업과정 DATA/2_E01/새 폴더/atm1_1411.dat",
		"/C/work/projects/100_KOGA/KOGA14/KOGA2014 설치작업과정 DATA/2_E01/rawData(2013_E01_SDCARD Backup)/t1.dat",
		"/C/work/projects/100_KOGA/KOGA14/KOGA2014 설치작업과정 DATA/2_E01/rawData(2013_E01_SDCARD Backup)/zp.dat",
		"/C/work/projects/100_KOGA/KOGA14/KOGA2014 설치작업과정 DATA/2_E01/새 폴더/zpulse_1411.dat",
		"/C/work/projects/100_KOGA/KOGA14/KOGA2014 설치작업과정 DATA/2_E01/rawData(2013_E01_SDCARD Backup)/hm.dat",
		"/C/work/projects/100_KOGA/KOGA14/KOGA2014 설치작업과정 DATA/2_E01/새 폴더/hmp155_1411.dat",
		"/C/work/projects/100_KOGA/KOGA14/KOGA2014 설치작업과정 DATA/2_E01/rawData(2013_E01_SDCARD Backup)/ai.dat",
		"/C/work/projects/100_KOGA/KOGA14/KOGA2014 설치작업과정 DATA/2_E01/새 폴더/aio_1411.dat",
		"/C/work/projects/100_KOGA/KOGA14/KOGA2014 설치작업과정 DATA/2_E01/rawData(2013_E01_SDCARD Backup)/ct.dat",
		"/C/work/projects/100_KOGA/KOGA14/KOGA2014 설치작업과정 DATA/2_E01/새 폴더/ct3919_1411.dat",
		"/C/work/projects/100_KOGA/KOGA14/KOGA2014 설치작업과정 DATA/2_E01/rawData(2013_E01_SDCARD Backup)/mo.dat",
		"/C/work/projects/100_KOGA/KOGA14/KOGA2014 설치작업과정 DATA/2_E01/새 폴더/mose_1411.dat",
		"/C/work/projects/100_KOGA/KOGA14/KOGA2014 설치작업과정 DATA/2_E01/새 폴더/aio_1410.dat",
		"/C/work/projects/100_KOGA/KOGA14/KOGA2014 설치작업과정 DATA/2_E01/새 폴더/zpulse_1409.dat",
		"/C/work/projects/100_KOGA/KOGA14/KOGA2014 설치작업과정 DATA/2_E01/새 폴더/atm1_1409.dat",
		"/C/work/projects/100_KOGA/KOGA14/KOGA2014 설치작업과정 DATA/2_E01/새 폴더/atm2_1409.dat",
		"/C/work/projects/100_KOGA/KOGA14/KOGA2014 설치작업과정 DATA/2_E01/새 폴더/ct3919_1410.dat",
		"/C/work/projects/100_KOGA/KOGA14/KOGA2014 설치작업과정 DATA/2_E01/새 폴더/gps_1410.dat",
		"/C/work/projects/100_KOGA/KOGA14/KOGA2014 설치작업과정 DATA/2_E01/새 폴더/history_1410.dat",
		"/C/work/projects/100_KOGA/KOGA14/KOGA2014 설치작업과정 DATA/2_E01/새 폴더/hmp155_1410.dat",
		"/C/work/projects/100_KOGA/KOGA14/KOGA2014 설치작업과정 DATA/2_E01/새 폴더/mose_1410.dat",
		"/C/work/projects/100_KOGA/KOGA14/KOGA2014 설치작업과정 DATA/2_E01/새 폴더/pt100_1409.dat",
		"/C/work/projects/100_KOGA/KOGA14/KOGA2014 설치작업과정 DATA/2_E01/새 폴더/send_1409.dat",
		"/C/work/projects/100_KOGA/KOGA14/KOGA2014 설치작업과정 DATA/2_E01/새 폴더/shock_1409.dat",
		"/H/_KOGA14설치_/KOGA2014 설치작업과정 DATA/1_E02/rawData(2013_E02_SDCARD Backup)/zp.dat",
		"/H/_KOGA14설치_/KOGA2014 설치작업과정 DATA/1_E02/새 폴더/zpulse_1410.dat",
		"/H/_KOGA14설치_/KOGA2014 설치작업과정 DATA/1_E02/rawData(2013_E02_SDCARD Backup)/t2.dat",
		"/H/_KOGA14설치_/KOGA2014 설치작업과정 DATA/1_E02/새 폴더/atm2_1410.dat",
		"/H/_KOGA14설치_/KOGA2014 설치작업과정 DATA/1_E02/rawData(2013_E02_SDCARD Backup)/t1.dat",
		"/H/_KOGA14설치_/KOGA2014 설치작업과정 DATA/1_E02/새 폴더/atm1_1311.dat",
		"/H/_KOGA14설치_/KOGA2014 설치작업과정 DATA/1_E02/rawData(2013_E02_SDCARD Backup)/sh.dat",
		"/H/_KOGA14설치_/KOGA2014 설치작업과정 DATA/1_E02/새 폴더/shock_1410.dat",
		"/H/_KOGA14설치_/KOGA2014 설치작업과정 DATA/1_E02/rawData(2013_E02_SDCARD Backup)/pt.dat",
		"/H/_KOGA14설치_/KOGA2014 설치작업과정 DATA/1_E02/새 폴더/pt100_1410.dat",
		"/H/_KOGA14설치_/KOGA2014 설치작업과정 DATA/1_E02/rawData(2013_E02_SDCARD Backup)/hi.dat",
		"/H/_KOGA14설치_/KOGA2014 설치작업과정 DATA/1_E02/rawData(2013_E02_SDCARD Backup)/gp.dat",
		"/H/_KOGA14설치_/KOGA2014 설치작업과정 DATA/1_E02/새 폴더/gps_1409.dat",
		"/H/_KOGA14설치_/KOGA2014 설치작업과정 DATA/1_E02/rawData(2013_E02_SDCARD Backup)/ai.dat",
		"/H/_KOGA14설치_/KOGA2014 설치작업과정 DATA/1_E02/새 폴더/aio_1410.dat",
		"/H/_KOGA14설치_/KOGA2014 설치작업과정 DATA/1_E02/rawData(2013_E02_SDCARD Backup)/hm.dat",
		"/H/_KOGA14설치_/KOGA2014 설치작업과정 DATA/1_E02/새 폴더/hmp155_1410.dat"
	],
	"find":
	{
		"height": 43.0
	},
	"find_in_files":
	{
		"height": 90.0,
		"where_history":
		[
			""
		]
	},
	"find_state":
	{
		"case_sensitive": false,
		"find_history":
		[
			"fwbuf",
			"get_cm",
			"f_mount",
			"f_mkfs",
			"setEnableHeartbeat",
			"syscmd",
			"setHeartbeatEvent",
			"lat_m",
			"lat_md",
			"lat_d",
			"gps_valid",
			"+",
			"measure_BAT_leval",
			"get_battery_level",
			"measure_BAT_leval",
			"bat",
			"depth_valid",
			"0",
			"2222",
			"return",
			"at",
			"u32",
			"40",
			"idx",
			"CONFIG_UART_RX_INTERRUPT",
			"uart_rx_int_enable",
			"BAT_val",
			"init",
			"uart_getch",
			"iri1_rcv_q_init",
			"iri_init_time_10sec",
			"1242",
			"set_iri2_init",
			"iri_rcv_get",
			"UartGetCh",
			"iri_rcv_get",
			"iri1_rcv_q_init",
			"iri_port",
			"port_no",
			"C_IRIDIUM_1",
			"uart_getch(3",
			"while(1) {  if (uart_getch(3,",
			"iri_response",
			"s.",
			"CONFIG_UART_RX_INTERRUPT",
			"FF",
			"s_msg2",
			"s_msg",
			"bin_header",
			"is_checkTime4Send",
			"fg_SEC_elapsed",
			"double",
			"0",
			"lat",
			"at",
			"lat",
			"mose_lat",
			"double",
			"1",
			"2",
			"sysWDT_init",
			"RTC_INIT_AT_BOOT",
			"WATCHDOG_V",
			"R_WDCNT",
			"SHOCK_W02",
			"E02_BAT_ADJUST",
			"dec_wifi_reset_tm",
			"WIFI_ON_TM",
			"100000",
			"boot",
			"KOGA_VER_STRING",
			"special",
			"is_special_ch_atm",
			"get_mose_Hmax",
			"SB_S_PTB210",
			"cat",
			"$PDTWL,MOT,HF,14,10,30,04,12,18.75,   0.035,   0.138,  -0.180,0*10",
			"fileSize",
			"Task_cat",
			"task_",
			"tick_fileTx",
			"wifi_reset_tm",
			"wifi_reset",
			"uart_getch(4",
			"R_GPOHIGH(5)",
			"cat_next",
			"m_sensor_proc",
			"E02_BAT_ADJUST",
			"E01_SHOCK",
			"DEBUG_SENSOR_SHOCK",
			"ctrl_sensor",
			"cmdSensorControl",
			"cmdSensorControl_1",
			"cmdSensorControl",
			"CONFIG_UART_TX_INTERRUPT",
			"();\n",
			"$PDTWL,MOT,HF,14,10,19,00,53,47.75",
			"$PDTWL,MOT,HF,14,10,19,00,48,32.25,",
			"$PDTWL,MOT,HF,14,10,19,00,14,48.75",
			"$PDTWL,MOT,HF,14,10,19,00,03,55.75,",
			"$PDTWL,MOT,HF,14,10,18,22,41,26.25,",
			"MOT,HF,14,10,18,22,41,24.25,  -0.053",
			"$PDTWL,POS,14,10,18,22,45,40.00,37,44.3712,N,130,35.0400,E,  26.0,0.9,1.4*1F",
			"HF,14,10,18,22,41,26.25",
			" \n",
			"1",
			"10",
			"set_debug_channel",
			"cat",
			"SensorBakSize.b.mose",
			"CMD_MV",
			"cmd_mv",
			"cmd_aa",
			"cmd_sbr",
			"cmd_sbw",
			"chk_file_size",
			"SensorBakSize.b.mose",
			"BUOY_ID",
			"get_battery_level",
			"SHT ACK Error",
			"BUOY_WEST",
			"W01",
			"make_msg_k1",
			"call_mose",
			"init",
			"sbinit",
			"init",
			"rtc"
		],
		"highlight": true,
		"in_selection": false,
		"preserve_case": false,
		"regex": false,
		"replace_history":
		[
		],
		"reverse": false,
		"show_context": true,
		"use_buffer2": true,
		"whole_word": false,
		"wrap": true
	},
	"groups":
	[
		{
			"selected": 1,
			"sheets":
			[
				{
					"buffer": 0,
					"file": "source/k_main.c",
					"semi_transient": false,
					"settings":
					{
						"buffer_size": 31568,
						"regions":
						{
						},
						"selection":
						[
							[
								16085,
								16085
							]
						],
						"settings":
						{
							"BracketHighlighterBusy": false,
							"bh_regions":
							[
								"bh_square",
								"bh_square_center",
								"bh_square_open",
								"bh_square_close",
								"bh_square_content",
								"bh_double_quote",
								"bh_double_quote_center",
								"bh_double_quote_open",
								"bh_double_quote_close",
								"bh_double_quote_content",
								"bh_default",
								"bh_default_center",
								"bh_default_open",
								"bh_default_close",
								"bh_default_content",
								"bh_c_define",
								"bh_c_define_center",
								"bh_c_define_open",
								"bh_c_define_close",
								"bh_c_define_content",
								"bh_curly",
								"bh_curly_center",
								"bh_curly_open",
								"bh_curly_close",
								"bh_curly_content",
								"bh_angle",
								"bh_angle_center",
								"bh_angle_open",
								"bh_angle_close",
								"bh_angle_content",
								"bh_regex",
								"bh_regex_center",
								"bh_regex_open",
								"bh_regex_close",
								"bh_regex_content",
								"bh_tag",
								"bh_tag_center",
								"bh_tag_open",
								"bh_tag_close",
								"bh_tag_content",
								"bh_round",
								"bh_round_center",
								"bh_round_open",
								"bh_round_close",
								"bh_round_content",
								"bh_single_quote",
								"bh_single_quote_center",
								"bh_single_quote_open",
								"bh_single_quote_close",
								"bh_single_quote_content",
								"bh_unmatched",
								"bh_unmatched_center",
								"bh_unmatched_open",
								"bh_unmatched_close",
								"bh_unmatched_content"
							],
							"origin_encoding": "UTF-8",
							"syntax": "Packages/C Improved/C Improved.tmLanguage",
							"translate_tabs_to_spaces": false,
							"vintage":
							{
								"_vintageous_glue_until_normal_mode": false,
								"action": null,
								"action_count": "",
								"mode": "mode_normal",
								"motion": null,
								"motion_count": "",
								"must_capture_register_name": false,
								"normal_insert_count": "1",
								"partial_sequence": "",
								"register": "\"",
								"sequence": "",
								"xpos": 80
							}
						},
						"translation.x": 0.0,
						"translation.y": 17740.0,
						"zoom_level": 1.0
					},
					"stack_index": 3,
					"type": "text"
				},
				{
					"buffer": 1,
					"file": "source/k_config.h",
					"semi_transient": false,
					"settings":
					{
						"buffer_size": 1984,
						"regions":
						{
						},
						"selection":
						[
							[
								108,
								108
							]
						],
						"settings":
						{
							"BracketHighlighterBusy": false,
							"bh_regions":
							[
								"bh_square",
								"bh_square_center",
								"bh_square_open",
								"bh_square_close",
								"bh_square_content",
								"bh_double_quote",
								"bh_double_quote_center",
								"bh_double_quote_open",
								"bh_double_quote_close",
								"bh_double_quote_content",
								"bh_default",
								"bh_default_center",
								"bh_default_open",
								"bh_default_close",
								"bh_default_content",
								"bh_c_define",
								"bh_c_define_center",
								"bh_c_define_open",
								"bh_c_define_close",
								"bh_c_define_content",
								"bh_curly",
								"bh_curly_center",
								"bh_curly_open",
								"bh_curly_close",
								"bh_curly_content",
								"bh_angle",
								"bh_angle_center",
								"bh_angle_open",
								"bh_angle_close",
								"bh_angle_content",
								"bh_regex",
								"bh_regex_center",
								"bh_regex_open",
								"bh_regex_close",
								"bh_regex_content",
								"bh_tag",
								"bh_tag_center",
								"bh_tag_open",
								"bh_tag_close",
								"bh_tag_content",
								"bh_round",
								"bh_round_center",
								"bh_round_open",
								"bh_round_close",
								"bh_round_content",
								"bh_single_quote",
								"bh_single_quote_center",
								"bh_single_quote_open",
								"bh_single_quote_close",
								"bh_single_quote_content",
								"bh_unmatched",
								"bh_unmatched_center",
								"bh_unmatched_open",
								"bh_unmatched_close",
								"bh_unmatched_content"
							],
							"origin_encoding": "ASCII",
							"syntax": "Packages/C Improved/C Improved.tmLanguage",
							"vintage":
							{
								"_vintageous_glue_until_normal_mode": true,
								"action": null,
								"action_count": "",
								"mode": "mode_insert",
								"motion": null,
								"motion_count": "",
								"must_capture_register_name": false,
								"normal_insert_count": "1",
								"partial_sequence": "",
								"register": "\"",
								"sequence": "",
								"xpos": 0
							}
						},
						"translation.x": 0.0,
						"translation.y": 1230.0,
						"zoom_level": 1.0
					},
					"stack_index": 2,
					"type": "text"
				}
			]
		},
		{
			"selected": 1,
			"sheets":
			[
				{
					"buffer": 2,
					"file": "source/k_rtc.c",
					"semi_transient": false,
					"settings":
					{
						"buffer_size": 3956,
						"regions":
						{
						},
						"selection":
						[
							[
								0,
								0
							]
						],
						"settings":
						{
							"BracketHighlighterBusy": false,
							"bh_regions":
							[
								"bh_square",
								"bh_square_center",
								"bh_square_open",
								"bh_square_close",
								"bh_square_content",
								"bh_double_quote",
								"bh_double_quote_center",
								"bh_double_quote_open",
								"bh_double_quote_close",
								"bh_double_quote_content",
								"bh_default",
								"bh_default_center",
								"bh_default_open",
								"bh_default_close",
								"bh_default_content",
								"bh_c_define",
								"bh_c_define_center",
								"bh_c_define_open",
								"bh_c_define_close",
								"bh_c_define_content",
								"bh_curly",
								"bh_curly_center",
								"bh_curly_open",
								"bh_curly_close",
								"bh_curly_content",
								"bh_angle",
								"bh_angle_center",
								"bh_angle_open",
								"bh_angle_close",
								"bh_angle_content",
								"bh_regex",
								"bh_regex_center",
								"bh_regex_open",
								"bh_regex_close",
								"bh_regex_content",
								"bh_tag",
								"bh_tag_center",
								"bh_tag_open",
								"bh_tag_close",
								"bh_tag_content",
								"bh_round",
								"bh_round_center",
								"bh_round_open",
								"bh_round_close",
								"bh_round_content",
								"bh_single_quote",
								"bh_single_quote_center",
								"bh_single_quote_open",
								"bh_single_quote_close",
								"bh_single_quote_content",
								"bh_unmatched",
								"bh_unmatched_center",
								"bh_unmatched_open",
								"bh_unmatched_close",
								"bh_unmatched_content"
							],
							"origin_encoding": "UTF-8",
							"syntax": "Packages/C Improved/C Improved.tmLanguage",
							"translate_tabs_to_spaces": false,
							"vintage":
							{
								"action": null,
								"action_count": "",
								"mode": "mode_normal",
								"motion": null,
								"motion_count": "",
								"must_capture_register_name": false,
								"partial_sequence": "",
								"register": "\"",
								"sequence": "",
								"xpos": 0
							}
						},
						"translation.x": 0.0,
						"translation.y": 3696.0,
						"zoom_level": 1.0
					},
					"stack_index": 4,
					"type": "text"
				},
				{
					"buffer": 3,
					"file": "source/k_cli.c",
					"semi_transient": false,
					"settings":
					{
						"buffer_size": 68263,
						"regions":
						{
						},
						"selection":
						[
							[
								15796,
								15796
							]
						],
						"settings":
						{
							"BracketHighlighterBusy": false,
							"bh_regions":
							[
								"bh_square",
								"bh_square_center",
								"bh_square_open",
								"bh_square_close",
								"bh_square_content",
								"bh_double_quote",
								"bh_double_quote_center",
								"bh_double_quote_open",
								"bh_double_quote_close",
								"bh_double_quote_content",
								"bh_default",
								"bh_default_center",
								"bh_default_open",
								"bh_default_close",
								"bh_default_content",
								"bh_c_define",
								"bh_c_define_center",
								"bh_c_define_open",
								"bh_c_define_close",
								"bh_c_define_content",
								"bh_curly",
								"bh_curly_center",
								"bh_curly_open",
								"bh_curly_close",
								"bh_curly_content",
								"bh_angle",
								"bh_angle_center",
								"bh_angle_open",
								"bh_angle_close",
								"bh_angle_content",
								"bh_regex",
								"bh_regex_center",
								"bh_regex_open",
								"bh_regex_close",
								"bh_regex_content",
								"bh_tag",
								"bh_tag_center",
								"bh_tag_open",
								"bh_tag_close",
								"bh_tag_content",
								"bh_round",
								"bh_round_center",
								"bh_round_open",
								"bh_round_close",
								"bh_round_content",
								"bh_single_quote",
								"bh_single_quote_center",
								"bh_single_quote_open",
								"bh_single_quote_close",
								"bh_single_quote_content",
								"bh_unmatched",
								"bh_unmatched_center",
								"bh_unmatched_open",
								"bh_unmatched_close",
								"bh_unmatched_content"
							],
							"origin_encoding": "UTF-8",
							"syntax": "Packages/C Improved/C Improved.tmLanguage",
							"tab_size": 4,
							"translate_tabs_to_spaces": true,
							"vintage":
							{
								"_vintageous_glue_until_normal_mode": true,
								"action": null,
								"action_count": "",
								"mode": "mode_insert",
								"motion": null,
								"motion_count": "",
								"must_capture_register_name": false,
								"normal_insert_count": "1",
								"partial_sequence": "",
								"register": "\"",
								"repeat_data":
								[
									"vi",
									"dd",
									"mode_internal_normal",
									null
								],
								"sequence": "",
								"xpos": 25
							}
						},
						"translation.x": 0.0,
						"translation.y": 13032.0,
						"zoom_level": 1.0
					},
					"stack_index": 0,
					"type": "text"
				},
				{
					"buffer": 4,
					"file": "SDK2.0/lib_src/serialflash.c",
					"semi_transient": false,
					"settings":
					{
						"buffer_size": 757,
						"regions":
						{
						},
						"selection":
						[
							[
								731,
								731
							]
						],
						"settings":
						{
							"BracketHighlighterBusy": false,
							"bh_regions":
							[
								"bh_square",
								"bh_square_center",
								"bh_square_open",
								"bh_square_close",
								"bh_square_content",
								"bh_double_quote",
								"bh_double_quote_center",
								"bh_double_quote_open",
								"bh_double_quote_close",
								"bh_double_quote_content",
								"bh_default",
								"bh_default_center",
								"bh_default_open",
								"bh_default_close",
								"bh_default_content",
								"bh_c_define",
								"bh_c_define_center",
								"bh_c_define_open",
								"bh_c_define_close",
								"bh_c_define_content",
								"bh_curly",
								"bh_curly_center",
								"bh_curly_open",
								"bh_curly_close",
								"bh_curly_content",
								"bh_angle",
								"bh_angle_center",
								"bh_angle_open",
								"bh_angle_close",
								"bh_angle_content",
								"bh_regex",
								"bh_regex_center",
								"bh_regex_open",
								"bh_regex_close",
								"bh_regex_content",
								"bh_tag",
								"bh_tag_center",
								"bh_tag_open",
								"bh_tag_close",
								"bh_tag_content",
								"bh_round",
								"bh_round_center",
								"bh_round_open",
								"bh_round_close",
								"bh_round_content",
								"bh_single_quote",
								"bh_single_quote_center",
								"bh_single_quote_open",
								"bh_single_quote_close",
								"bh_single_quote_content",
								"bh_unmatched",
								"bh_unmatched_center",
								"bh_unmatched_open",
								"bh_unmatched_close",
								"bh_unmatched_content"
							],
							"origin_encoding": "ASCII",
							"syntax": "Packages/C Improved/C Improved.tmLanguage",
							"translate_tabs_to_spaces": false,
							"vintage":
							{
								"action": null,
								"action_count": "",
								"mode": "mode_normal",
								"motion": null,
								"motion_count": "",
								"must_capture_register_name": false,
								"partial_sequence": "",
								"register": "\"",
								"sequence": "",
								"xpos": 20
							}
						},
						"translation.x": 0.0,
						"translation.y": 0.0,
						"zoom_level": 1.0
					},
					"stack_index": 1,
					"type": "text"
				}
			]
		}
	],
	"incremental_find":
	{
		"height": 40.0
	},
	"input":
	{
		"height": 29.0
	},
	"layout":
	{
		"cells":
		[
			[
				0,
				0,
				1,
				1
			],
			[
				1,
				0,
				2,
				1
			]
		],
		"cols":
		[
			0.0,
			0.5,
			1.0
		],
		"rows":
		[
			0.0,
			1.0
		]
	},
	"menu_visible": false,
	"output.exec":
	{
		"height": 88.0
	},
	"output.find_results":
	{
		"height": 0.0
	},
	"project": "echo2.sublime-project",
	"replace":
	{
		"height": 56.0
	},
	"save_all_on_build": true,
	"select_file":
	{
		"height": 0.0,
		"selected_items":
		[
			[
				"rtc",
				"source\\k_rtc.c"
			],
			[
				"con",
				"source\\k_config.h"
			],
			[
				"iri",
				"source\\k_iridium.c"
			],
			[
				"gps",
				"source\\k_gps.c"
			],
			[
				"msg",
				"source\\k_msg.c"
			],
			[
				"tim",
				"source\\k_timer.c"
			],
			[
				"mai",
				"source\\k_main.c"
			],
			[
				"cli",
				"source\\k_cli.c"
			],
			[
				"in",
				"source\\k_includes.h"
			],
			[
				"kcli",
				"source\\k_cli.c"
			],
			[
				"ktim",
				"source\\k_timer.c"
			],
			[
				"kin",
				"source\\k_includes.h"
			],
			[
				"gps.h",
				"source\\k_gps.h"
			],
			[
				"ir",
				"source\\k_iridium.c"
			],
			[
				"uart",
				"SDK2.0\\lib_src\\uart.c"
			],
			[
				"ct",
				"source\\k_ct3919.h"
			],
			[
				"ffcon",
				"SDK2.0\\include\\fatfs\\ffconf.h"
			],
			[
				"uar",
				"SDK2.0\\lib_src\\uart.c"
			],
			[
				"tri",
				"source\\startup\\trip_board.c"
			],
			[
				"conf",
				"source\\k_config.h"
			],
			[
				"kms",
				"source\\k_msg.c"
			],
			[
				"msg.",
				"source\\k_msg.h"
			],
			[
				"ms",
				"source\\k_msg.c"
			],
			[
				"ma",
				"source\\k_main.h"
			],
			[
				"confi",
				"source\\k_config.h"
			],
			[
				"main",
				"source\\k_main.c"
			],
			[
				"adst",
				"SDK2.0\\include\\adstar.h"
			],
			[
				"sb",
				"source\\k_sb16c1058.c"
			],
			[
				"mo",
				"source\\k_mose.c"
			],
			[
				"aio",
				"source\\k_aio.c"
			],
			[
				"bu",
				"source\\buoy_waves2.c"
			],
			[
				"kmose",
				"source\\k_mose.c"
			],
			[
				"clih",
				"source\\k_cli.h"
			],
			[
				"ti",
				"source\\k_timer.h"
			],
			[
				"atm",
				"source\\k_atm.c"
			],
			[
				"hmp",
				"source\\k_hmp155.c"
			],
			[
				"sho",
				"source\\k_shock.c"
			],
			[
				"cl",
				"source\\k_cli.c"
			],
			[
				"mos",
				"source\\k_mose.c"
			],
			[
				"wa",
				"source\\buoy_waves2.c"
			],
			[
				"wave",
				"source\\obj\\buoy_waves2.d"
			],
			[
				"kdch",
				"source\\k_dcs.h"
			],
			[
				"gp",
				"source\\k_gps.c"
			],
			[
				"ksr",
				"source\\k_SR10.h"
			],
			[
				"k_.h",
				"source\\k_aio.h"
			],
			[
				"ptb",
				"source\\k_ptb210.c"
			],
			[
				"ksb",
				"source\\k_sb16c1058.c"
			],
			[
				"kptb",
				"source\\k_ptb210.c"
			],
			[
				"kaio",
				"source\\k_aio.c"
			],
			[
				"wm",
				"source\\k_WM800.h"
			],
			[
				"lm",
				"source\\k_LMP90100.c"
			],
			[
				"sr",
				"source\\k_SR10.c"
			],
			[
				"dcs",
				"source\\k_dcs.h"
			],
			[
				"lmp",
				"source\\k_LMP90100.c"
			],
			[
				"kma",
				"source\\k_main.c"
			],
			[
				"kwm",
				"source\\k_WM800.h"
			],
			[
				"kwc",
				"source\\k_WM800.c"
			],
			[
				"rdc",
				"source\\k_rdcp.c"
			],
			[
				"rdcp",
				"source\\c4_rdcp.c"
			],
			[
				"kmsg",
				"source\\k_msg.c"
			],
			[
				"kct",
				"source\\k_ct3919.c"
			],
			[
				"pt",
				"source\\k_ptb210.c"
			],
			[
				"kti",
				"source\\k_timer.h"
			],
			[
				"kmai",
				"source\\k_main.c"
			],
			[
				"kt",
				"source\\k_timer.h"
			],
			[
				"kinc",
				"source\\k_includes.h"
			],
			[
				"timer",
				"source\\k_timer.c"
			],
			[
				"mose",
				"source\\k_mose.h"
			],
			[
				"inc",
				"source\\k_includes.h"
			],
			[
				"16",
				"source\\k_sb16c1058.c"
			],
			[
				"kcon",
				"source\\k_config.h"
			],
			[
				"kir",
				"source\\k_iridium.h"
			],
			[
				"k_in",
				"source\\k_includes.h"
			],
			[
				"k_w",
				"source\\k_WM800.c"
			],
			[
				"kg",
				"source\\k_gps.c"
			],
			[
				"kht",
				"source\\k_HT01.h"
			],
			[
				"kgp",
				"source\\k_gps.c"
			],
			[
				"ksh",
				"source\\k_shock.c"
			],
			[
				"ksho",
				"source\\k_shock.c"
			],
			[
				"kmain",
				"source\\k_main.c"
			],
			[
				"kat",
				"source\\k_atm.c"
			],
			[
				"ai",
				"source\\k_aio.c"
			],
			[
				"kai",
				"source\\k_aio.c"
			],
			[
				"km",
				"source\\k_msg.c"
			],
			[
				"kmo",
				"source\\k_mose.h"
			],
			[
				"ks",
				"source\\k_sdc.c"
			],
			[
				"katm",
				"source\\k_atm.c"
			],
			[
				"kdc",
				"source\\k_dcs.c"
			],
			[
				"kh",
				"source\\k_hmp155.c"
			],
			[
				"khm",
				"source\\k_hmp155.c"
			],
			[
				"trip",
				"source\\startup\\trip_board.c"
			],
			[
				"ki",
				"source\\k_iridium.c"
			],
			[
				"kmainh",
				"source\\k_main.h"
			],
			[
				"kclic",
				"source\\k_cli.c"
			],
			[
				"b",
				"source\\buoy_waves2.c"
			],
			[
				"kiri",
				"source\\k_iridium.c"
			],
			[
				"kc",
				"source\\k_cli.h"
			],
			[
				"sh11",
				"source\\k_sh11.c"
			],
			[
				"sh",
				"source\\k_shock.c"
			],
			[
				"kmsh",
				"source\\k_msg.h"
			],
			[
				"ktih",
				"source\\k_timer.h"
			],
			[
				"kmos",
				"source\\k_mose.c"
			],
			[
				"ksdc",
				"source\\k_sdc.c"
			],
			[
				"kmaih",
				"source\\k_main.h"
			],
			[
				"kclih",
				"source\\k_cli.h"
			],
			[
				"kwi",
				"source\\k_wifi.c"
			],
			[
				"k",
				"source\\k_ct3919.c"
			],
			[
				"kw",
				"source\\k_wifi.c"
			],
			[
				"at",
				"source\\k_atm.c"
			],
			[
				"kincl",
				"source\\k_includes.h"
			],
			[
				"mainh",
				"source\\k_main.h"
			],
			[
				"eglcon",
				"SDK2.0\\include\\egl\\egl_config.h"
			],
			[
				"stk",
				"SDK2.0\\include\\stk_board.h"
			],
			[
				"libc",
				"SDK2.0\\include\\lib_config.h"
			],
			[
				"kgps",
				"source\\k_gps.h"
			],
			[
				"155",
				"source\\k_hmp155.c"
			],
			[
				"ktimh",
				"source\\k_timer.h"
			],
			[
				"ksys",
				"source\\k_sysMCU.h"
			],
			[
				"kptbc",
				"source\\k_ptb210.c"
			],
			[
				"shh",
				"source\\k_shock.h"
			],
			[
				"kmsgc",
				"source\\k_msg.c"
			],
			[
				"kmsgh",
				"source\\k_msg.h"
			],
			[
				"kmaic",
				"source\\k_main.c"
			],
			[
				"timec",
				"source\\k_timer.c"
			],
			[
				"irih",
				"source\\k_iridium.h"
			],
			[
				"sysmh",
				"source\\k_sysMCU.h"
			],
			[
				"sysc",
				"source\\k_sysMCU.c"
			],
			[
				"k_",
				"source\\k_gps.c"
			]
		],
		"width": 0.0
	},
	"select_project":
	{
		"height": 500.0,
		"selected_items":
		[
			[
				"",
				"E:\\GitHub\\StBuoy\\stBuoy.sublime-project"
			]
		],
		"width": 646.0
	},
	"select_symbol":
	{
		"height": 392.0,
		"selected_items":
		[
		],
		"width": 392.0
	},
	"selected_group": 1,
	"settings":
	{
		"_vintageous_last_char_search_command": "vi_t",
		"_vintageous_last_character_search": "i",
		"_vintageous_reset_during_init": true,
		"vintage":
		{
			"_cmdline_cd": "C:\\work\\projects\\210_EchoBuoy\\Firmware2\\source"
		}
	},
	"show_minimap": true,
	"show_open_files": true,
	"show_tabs": true,
	"side_bar_visible": false,
	"side_bar_width": 202.0,
	"status_bar_visible": true,
	"template_settings":
	{
		"max_columns": 2
	}
}
